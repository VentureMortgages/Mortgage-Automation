---
phase: 04-crm-integration
plan: 04
type: tdd
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src/crm/checklist-sync.ts
  - src/crm/__tests__/checklist-mapper.test.ts
  - src/crm/__tests__/checklist-sync.test.ts
  - src/crm/__tests__/tasks.test.ts
autonomous: true

must_haves:
  truths:
    - "syncChecklistToCrm orchestrates contact upsert, field update, task creation, and pipeline stage transition in correct order (SC1+SC2+SC3)"
    - "Checklist mapper correctly transforms employed-purchase fixture into CRM field updates with PRE/FULL counts"
    - "Checklist mapper correctly handles co-borrower fixture (multiple borrower names in summary)"
    - "addBusinessDays skips weekends correctly (Friday+1=Monday, Saturday+1=Monday)"
    - "computeDocStatus returns correct status for all state transitions (Not Started -> In Progress -> PRE Complete -> All Complete)"
    - "Orchestrator creates review task for Cat and does NOT create PRE-readiness task on initial sync (CRM-02)"
  artifacts:
    - path: "src/crm/checklist-sync.ts"
      provides: "Main orchestrator that ties all CRM operations together"
      exports: ["syncChecklistToCrm"]
    - path: "src/crm/__tests__/checklist-mapper.test.ts"
      provides: "Pure function tests for mapper (no mocks needed)"
      min_lines: 80
    - path: "src/crm/__tests__/checklist-sync.test.ts"
      provides: "Orchestrator tests with mocked CRM services"
      min_lines: 60
    - path: "src/crm/__tests__/tasks.test.ts"
      provides: "Business day calculation and task formatting tests"
      min_lines: 40
  key_links:
    - from: "src/crm/checklist-sync.ts"
      to: "src/crm/contacts.ts"
      via: "Calls upsertContact to create/update CRM contact"
      pattern: "import.*upsertContact.*from.*contacts"
    - from: "src/crm/checklist-sync.ts"
      to: "src/crm/checklist-mapper.ts"
      via: "Calls mapChecklistToFields to build CRM field payload"
      pattern: "import.*mapChecklistToFields.*from.*checklist-mapper"
    - from: "src/crm/checklist-sync.ts"
      to: "src/crm/tasks.ts"
      via: "Calls createReviewTask for Cat's review workflow"
      pattern: "import.*createReviewTask.*from.*tasks"
    - from: "src/crm/checklist-sync.ts"
      to: "src/crm/opportunities.ts"
      via: "Calls moveToCollectingDocs for pipeline stage transition"
      pattern: "import.*moveToCollectingDocs.*from.*opportunities"
    - from: "src/crm/__tests__/checklist-mapper.test.ts"
      to: "src/checklist/__tests__/fixtures/index.ts"
      via: "Reuses Phase 3 test fixtures for integration testing"
      pattern: "import.*fixtures"
---

<objective>
Build the main orchestrator function and comprehensive test suite for the CRM integration layer.

Purpose: The orchestrator (`syncChecklistToCrm`) is the single entry point that Phase 1 (webhook handler) will call when a Finmo application is submitted. It ties together all CRM operations in the correct order: upsert contact, update custom fields with checklist data, create review task for Cat, and move pipeline to "Collecting Documents." The test suite validates the pure mapper functions with real fixture data and the orchestrator with mocked CRM services.

Output: Working orchestrator function + ~20-30 tests validating mapper logic, business day calculation, doc status computation, and orchestration flow.
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-crm-integration/04-RESEARCH.md
@.planning/phases/04-crm-integration/04-01-SUMMARY.md
@.planning/phases/04-crm-integration/04-02-SUMMARY.md
@.planning/phases/04-crm-integration/04-03-SUMMARY.md
@src/checklist/types/checklist.ts
@src/checklist/__tests__/fixtures/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build the syncChecklistToCrm orchestrator</name>
  <files>src/crm/checklist-sync.ts</files>
  <action>
Create `src/crm/checklist-sync.ts` — the main orchestration function that the webhook handler (Phase 1) will call.

**Function: `syncChecklistToCrm(input: SyncChecklistInput): Promise<SyncChecklistResult>`**

```typescript
interface SyncChecklistInput {
  checklist: GeneratedChecklist;           // Phase 3 output
  borrowerEmail: string;                   // Main borrower email for contact upsert
  borrowerFirstName: string;               // Main borrower first name
  borrowerLastName: string;                // Main borrower last name
  borrowerPhone?: string;                  // Optional phone number
  finmoDealId?: string;                    // For linking to existing Finmo contact
}

interface SyncChecklistResult {
  contactId: string;
  taskId: string;                          // Cat's review task
  opportunityId: string;                   // Pipeline opportunity
  fieldsUpdated: number;                   // Count of custom fields written
}
```

Implementation — execute in this order:

1. **Map checklist to CRM fields** (pure, no API call):
```typescript
const fieldUpdates = mapChecklistToFields(checklist, { fieldIds: crmConfig.fieldIds });
```

2. **Upsert contact** with custom field updates:
```typescript
const { contactId } = await upsertContact({
  email: borrowerEmail,
  firstName: borrowerFirstName,
  lastName: borrowerLastName,
  phone: borrowerPhone,
  customFields: fieldUpdates,
});
```

3. **Create review task for Cat**:
```typescript
const borrowerName = `${borrowerFirstName} ${borrowerLastName}`;
const summary = buildChecklistSummary(checklist);
const taskId = await createReviewTask(contactId, borrowerName);
```

Note: the task body should include the checklist summary built by `buildChecklistSummary`. Modify `createReviewTask` to accept an optional `body` parameter if it doesn't already, OR call the raw task creation function. If `createReviewTask` in 04-02 already has a fixed body, compose the summary into it here.

4. **Move pipeline to Collecting Documents**:
```typescript
const opportunityId = await moveToCollectingDocs(contactId, borrowerName);
```

5. **Return result**:
```typescript
return {
  contactId,
  taskId,
  opportunityId,
  fieldsUpdated: fieldUpdates.length,
};
```

**Error handling:**
- If contact upsert fails, abort entirely (can't create task or opportunity without contactId)
- If task creation fails, log warning but continue (task is important but not critical — Cat can still see custom fields)
- If opportunity upsert fails, log warning but continue (pipeline stage is nice-to-have)
- Return partial result if some operations fail: add optional `errors: string[]` to SyncChecklistResult

**Idempotency:**
- Contact upsert is inherently idempotent (dedup by email)
- Custom field updates overwrite previous values (safe for retry)
- Task creation is NOT idempotent (creates duplicates on retry). Mitigation: caller should deduplicate at webhook level (Phase 1 handles this with idempotency keys). Document this in a JSDoc comment.
- Opportunity upsert is idempotent (dedup by contactId + pipelineId)

Also export the input/result types from this module.

Import from sibling modules using `.js` extensions.
  </action>
  <verify>Run `npx tsc --noEmit` — checklist-sync.ts compiles with no errors. Verify it imports from all CRM service modules (contacts, tasks, opportunities, checklist-mapper).</verify>
  <done>Orchestrator function executes contact upsert, field update, task creation, and pipeline transition in correct order. Partial failures are handled gracefully with warnings. Non-idempotent operations (task creation) are documented for upstream dedup responsibility.</done>
</task>

<task type="auto">
  <name>Task 2: Write test suite for mapper, utilities, and orchestrator</name>
  <files>src/crm/__tests__/checklist-mapper.test.ts, src/crm/__tests__/checklist-sync.test.ts, src/crm/__tests__/tasks.test.ts</files>
  <action>
Write comprehensive tests using Vitest. Use the Phase 3 test fixtures where applicable.

**`src/crm/__tests__/checklist-mapper.test.ts`** — Pure function tests (~12-15 tests):

```
describe('mapChecklistToFields', () => {
  test('produces correct number of field updates (9 fields)', () => {
    // Use employedPurchase fixture, run generateChecklist, then mapChecklistToFields
    // Assert: result.length === 9 (one for each DOC_TRACKING_FIELD)
    // Use a mock config with fake field IDs
  })

  test('PRE count matches checklist stats', () => {
    // Assert: field with docStatus ID has value 'In Progress'
    // Assert: preDocsTotal field value matches checklist.stats.preItems
    // Assert: preDocsReceived field value is 0 (initial sync)
  })

  test('FULL count matches checklist stats', () => {
    // Assert: fullDocsTotal matches
    // Assert: fullDocsReceived is 0
  })

  test('missing docs JSON contains document names', () => {
    // Assert: missingDocs field contains valid JSON
    // Assert: parsed array length matches total items
    // Assert: array contains string items (doc names), no objects
  })

  test('received docs JSON is empty array initially', () => {
    // Assert: receivedDocs field is '[]'
  })

  test('doc request sent date is today', () => {
    // Assert: docRequestSent field matches today's date in YYYY-MM-DD format
  })
})

describe('mapChecklistToDocNames', () => {
  test('extracts document field not displayName', () => {
    // Create ChecklistItem with different document and displayName
    // Assert: result uses document, not displayName
  })

  test('handles empty items array', () => {
    // Assert: returns []
  })

  test('contains no PII (sanity check)', () => {
    // Use fixture, generate checklist, extract doc names
    // Assert: no name in array contains dollar amounts, SIN patterns, email addresses
    // Simple regex check: no $ amounts, no xxx-xxx-xxx patterns
  })
})

describe('computeDocStatus', () => {
  test('returns Not Started when no docs received', () => {
    expect(computeDocStatus(5, 0, 3, 0)).toBe('Not Started');
  })

  test('returns In Progress when some PRE received', () => {
    expect(computeDocStatus(5, 2, 3, 0)).toBe('In Progress');
  })

  test('returns In Progress when some FULL received but PRE not complete', () => {
    expect(computeDocStatus(5, 3, 3, 1)).toBe('In Progress');
  })

  test('returns PRE Complete when all PRE received', () => {
    expect(computeDocStatus(5, 5, 3, 0)).toBe('PRE Complete');
  })

  test('returns PRE Complete when all PRE but only some FULL received', () => {
    expect(computeDocStatus(5, 5, 3, 2)).toBe('PRE Complete');
  })

  test('returns All Complete when everything received', () => {
    expect(computeDocStatus(5, 5, 3, 3)).toBe('All Complete');
  })

  test('handles zero totals (no docs)', () => {
    expect(computeDocStatus(0, 0, 0, 0)).toBe('All Complete');
  })
})

describe('buildChecklistSummary', () => {
  test('includes total counts', () => {
    // Use fixture, check summary contains numbers
  })

  test('includes borrower names for co-borrower', () => {
    // Use coBorrowerMixed fixture
    // Assert: summary mentions both borrower names
  })

  test('includes warning count when warnings exist', () => {
    // Use minimal fixture (may produce warnings)
  })
})
```

To test `mapChecklistToFields`, create a mock config object with fake field IDs:
```typescript
const mockFieldIds = {
  docStatus: 'test-doc-status',
  docRequestSent: 'test-doc-sent',
  missingDocs: 'test-missing',
  receivedDocs: 'test-received',
  preDocsTotal: 'test-pre-total',
  preDocsReceived: 'test-pre-received',
  fullDocsTotal: 'test-full-total',
  fullDocsReceived: 'test-full-received',
  lastDocReceived: 'test-last-doc',
};
```

For tests that need a GeneratedChecklist, import `generateChecklist` from Phase 3 engine and use the Phase 3 test fixtures:
```typescript
import { generateChecklist } from '../../checklist/engine/index.js';
import { fixtures } from '../../checklist/__tests__/fixtures/index.js';
```

**`src/crm/__tests__/tasks.test.ts`** — Business day calculation tests (~8 tests):

```
describe('addBusinessDays', () => {
  test('Monday + 1 = Tuesday', () => {
    const monday = new Date('2026-02-16'); // Monday
    expect(addBusinessDays(monday, 1).toISOString().split('T')[0]).toBe('2026-02-17');
  })

  test('Friday + 1 = Monday', () => {
    const friday = new Date('2026-02-13'); // Friday
    expect(addBusinessDays(friday, 1).toISOString().split('T')[0]).toBe('2026-02-16');
  })

  test('Saturday + 1 = Monday', () => {
    const saturday = new Date('2026-02-14'); // Saturday
    expect(addBusinessDays(saturday, 1).toISOString().split('T')[0]).toBe('2026-02-16');
  })

  test('Sunday + 1 = Monday', () => {
    const sunday = new Date('2026-02-15'); // Sunday
    expect(addBusinessDays(sunday, 1).toISOString().split('T')[0]).toBe('2026-02-16');
  })

  test('Friday + 2 = Tuesday', () => {
    const friday = new Date('2026-02-13');
    expect(addBusinessDays(friday, 2).toISOString().split('T')[0]).toBe('2026-02-17');
  })

  test('Wednesday + 5 = Wednesday next week', () => {
    const wed = new Date('2026-02-11'); // Wednesday
    expect(addBusinessDays(wed, 5).toISOString().split('T')[0]).toBe('2026-02-18');
  })

  test('Monday + 0 = Monday', () => {
    const monday = new Date('2026-02-16');
    expect(addBusinessDays(monday, 0).toISOString().split('T')[0]).toBe('2026-02-16');
  })

  test('Thursday + 1 = Friday', () => {
    const thursday = new Date('2026-02-12');
    expect(addBusinessDays(thursday, 1).toISOString().split('T')[0]).toBe('2026-02-13');
  })
})
```

**`src/crm/__tests__/checklist-sync.test.ts`** — Orchestrator tests with mocks (~8 tests):

Use `vi.mock()` to mock the CRM service modules:
```typescript
vi.mock('../contacts.js', () => ({
  upsertContact: vi.fn().mockResolvedValue({ contactId: 'test-contact-123', isNew: true }),
}));
vi.mock('../tasks.js', () => ({
  createReviewTask: vi.fn().mockResolvedValue('test-task-456'),
  createPreReadinessTask: vi.fn().mockResolvedValue('test-task-789'),
  addBusinessDays: vi.fn().mockImplementation((d, n) => d),
}));
vi.mock('../opportunities.js', () => ({
  moveToCollectingDocs: vi.fn().mockResolvedValue('test-opp-101'),
}));
vi.mock('../checklist-mapper.js', () => ({
  mapChecklistToFields: vi.fn().mockReturnValue([
    { id: 'f1', field_value: 'In Progress' },
    { id: 'f2', field_value: 5 },
  ]),
  buildChecklistSummary: vi.fn().mockReturnValue('Test summary'),
}));
```

Tests:
```
describe('syncChecklistToCrm', () => {
  test('calls upsertContact with borrower details', () => {
    // Run syncChecklistToCrm
    // Assert: upsertContact called with email, firstName, lastName
  })

  test('passes mapped field updates to contact upsert', () => {
    // Assert: upsertContact customFields match mapChecklistToFields output
  })

  test('creates review task for Cat', () => {
    // Assert: createReviewTask called with contactId and borrower name
  })

  test('moves pipeline to Collecting Documents', () => {
    // Assert: moveToCollectingDocs called with contactId and borrower name
  })

  test('returns complete result', () => {
    // Assert: result has contactId, taskId, opportunityId, fieldsUpdated
  })

  test('handles contact upsert failure', () => {
    // Mock upsertContact to throw
    // Assert: syncChecklistToCrm throws (can't continue without contact)
  })

  test('handles task creation failure gracefully', () => {
    // Mock createReviewTask to throw
    // Assert: syncChecklistToCrm still returns with errors array
  })

  test('handles opportunity failure gracefully', () => {
    // Mock moveToCollectingDocs to throw
    // Assert: syncChecklistToCrm still returns with errors array
  })
})
```

**TDD Flow:**
1. Write ALL tests first (RED)
2. Run `npx vitest run` — some tests may fail due to import issues or implementation gaps
3. Fix the orchestrator and any issues found
4. Run `npx vitest run` — all tests should pass (GREEN)
5. Fix any edge cases discovered during testing

Also update the CRM barrel export (`src/crm/index.ts`) to include `syncChecklistToCrm` and its types if not already exported.
  </action>
  <verify>
Run `npx vitest run` — ALL tests pass.

Run `npx vitest run --reporter=verbose` to see individual test names.

Expected: ~28-35 tests across 3 test files, 0 failures.

Also verify: `npx tsc --noEmit` still passes.
  </verify>
  <done>
Orchestrator ties together all CRM operations in correct order. Tests validate:
- Mapper produces correct field counts and formats (12+ tests)
- computeDocStatus handles all state transitions (7 tests)
- addBusinessDays skips weekends correctly (8 tests)
- Orchestrator calls services in correct order and handles partial failures (8 tests)
All tests pass. All 5 phase success criteria are addressed.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all tests pass (0 failures)
2. `npx tsc --noEmit` — compiles clean
3. Test count is ~28-35 cases across 3 files
4. Orchestrator creates contact, updates fields, creates task, transitions pipeline (SC1, SC2, SC3)
5. Mapper correctly computes PRE/FULL counts from checklist (SC3)
6. computeDocStatus returns correct labels for PRE-readiness (SC4 foundation)
7. addBusinessDays correctly handles weekends
8. All tests use mock CRM services (no live API calls)
9. Phase 3 fixtures are reused for mapper integration tests
</verification>

<success_criteria>
- syncChecklistToCrm is a single entry point for the webhook handler to call
- All 5 phase success criteria have code supporting them:
  - SC1: Contact created/updated (upsertContact)
  - SC2: Review task created for Cat (createReviewTask)
  - SC3: Checklist status visible in custom fields (mapChecklistToFields)
  - SC4: PRE-readiness detection logic exists (computeDocStatus, createPreReadinessTask)
  - SC5: Cat can view status via custom fields in CRM (fields are populated by mapper)
- Mapper is tested with real Phase 3 checklist fixtures
- Orchestrator handles partial failures gracefully
- All tests pass with 0 failures
</success_criteria>

<output>
After completion, create `.planning/phases/04-crm-integration/04-04-SUMMARY.md`
</output>

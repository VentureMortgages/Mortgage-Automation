---
phase: 04-crm-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/crm/contacts.ts
  - src/crm/tasks.ts
  - src/crm/opportunities.ts
autonomous: true

must_haves:
  truths:
    - "Contact can be created or updated in MyBrokerPro by email with Finmo borrower details (CRM-01)"
    - "Task can be created in MyBrokerPro assigned to a specific user with due date (CRM-02 foundation)"
    - "Opportunity can be upserted to track pipeline stage (Collecting Documents, All Docs Received)"
    - "Existing Finmo-synced fields (Deal ID, Application ID, Deal Link) are never overwritten"
  artifacts:
    - path: "src/crm/contacts.ts"
      provides: "Contact upsert and lookup operations"
      exports: ["upsertContact", "findContactByEmail"]
    - path: "src/crm/tasks.ts"
      provides: "Task creation for Cat (review) and Taylor (PRE-readiness)"
      exports: ["createReviewTask", "createPreReadinessTask"]
    - path: "src/crm/opportunities.ts"
      provides: "Pipeline opportunity upsert and stage transitions"
      exports: ["upsertOpportunity", "moveToCollectingDocs", "moveToAllDocsReceived"]
  key_links:
    - from: "src/crm/contacts.ts"
      to: "src/crm/client.ts"
      via: "Uses GHL SDK/client for API calls"
      pattern: "import.*from.*client"
    - from: "src/crm/contacts.ts"
      to: "src/crm/types/index.ts"
      via: "Uses CrmContactUpsertInput and EXISTING_FIELDS constants"
      pattern: "import.*from.*types"
    - from: "src/crm/tasks.ts"
      to: "src/crm/config.ts"
      via: "Reads Cat and Taylor user IDs from config"
      pattern: "crmConfig\\.userIds"
---

<objective>
Build the CRM service modules for contacts, tasks, and pipeline opportunities.

Purpose: These are the core CRUD operations the automation needs: create/update contacts when Finmo applications arrive, create tasks for Cat and Taylor, and manage pipeline stage transitions. Each module wraps GHL SDK/API calls with domain-specific functions that the orchestrator (Plan 04) will compose into the full sync workflow.

Output: Three CRM service modules with typed, tested-ready functions for contact upsert, task creation, and opportunity management.
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-crm-integration/04-RESEARCH.md
@.planning/phases/04-crm-integration/04-01-SUMMARY.md
@.planning/MBP_CRM_REFERENCE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build contact upsert and lookup service</name>
  <files>src/crm/contacts.ts</files>
  <action>
Create `src/crm/contacts.ts` — wraps GHL contact operations with domain-specific functions.

**Function 1: `upsertContact(input: UpsertContactInput): Promise<UpsertContactResult>`**

Uses the GHL upsert endpoint (`POST /contacts/upsert`) to create or update a contact by email.

```typescript
interface UpsertContactInput {
  email: string;
  firstName: string;
  lastName: string;
  phone?: string;
  source?: string;
  customFields?: CrmCustomFieldUpdate[];
}

interface UpsertContactResult {
  contactId: string;
  isNew: boolean; // true if created, false if updated existing
}
```

Implementation:
1. Call the GHL upsert endpoint with `locationId` from config
2. Pass `email`, `firstName`, `lastName`, `phone` (if provided)
3. Pass `customFields` array in the correct format: `[{ id, field_value }]`
4. CRITICAL: Do NOT include `EXISTING_FIELDS.FINMO_DEAL_ID`, `EXISTING_FIELDS.FINMO_APPLICATION_ID`, or `EXISTING_FIELDS.FINMO_DEAL_LINK` in the customFields update — these are managed by Finmo's own sync. Only include doc tracking fields.
5. Return the contact ID and whether it was newly created

If using the SDK: `ghl.contacts.upsertContact(...)` — check the actual SDK method signature from 04-01 summary.

If using raw fetch (fallback from Plan 01):
```typescript
const response = await fetch(`${config.baseUrl}/contacts/upsert`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${config.apiKey}`,
    'Version': '2021-07-28',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    locationId: config.locationId,
    email: input.email,
    firstName: input.firstName,
    lastName: input.lastName,
    ...(input.phone ? { phone: input.phone } : {}),
    ...(input.source ? { source: input.source } : {}),
    customFields: input.customFields ?? [],
  }),
});
```

**Function 2: `findContactByEmail(email: string): Promise<string | null>`**

Search for an existing contact by email. Returns the contact ID if found, null otherwise.

Uses `POST /contacts/search` (the v2 search endpoint, NOT the deprecated GET):
```typescript
const response = await fetch(`${config.baseUrl}/contacts/search`, {
  method: 'POST',
  headers: { ... },
  body: JSON.stringify({
    locationId: config.locationId,
    filters: [
      { field: 'email', operator: 'eq', value: email }
    ],
  }),
});
```

If the search endpoint format differs from above, try the simpler query format:
```typescript
body: JSON.stringify({
  locationId: config.locationId,
  query: email,
})
```

Return the first matching contact ID or null.

**Error handling:**
- Wrap all API calls in try/catch
- On rate limit (429), throw a typed `CrmRateLimitError` that upstream can handle with retry
- On auth error (401), throw `CrmAuthError` with a message to check the API key
- On other errors, throw `CrmApiError` with status code and response body
- NEVER log email addresses or phone numbers in error messages (PII safety)

Import client/config from Plan 01 files using `.js` extensions.
  </action>
  <verify>Run `npx tsc --noEmit` — contacts.ts compiles with no errors. Verify exports: `upsertContact` and `findContactByEmail`.</verify>
  <done>Contact service provides upsert (create or update by email) and lookup functions. Finmo-managed fields are never overwritten. Error handling includes typed errors for rate limits and auth failures. No PII in error messages.</done>
</task>

<task type="auto">
  <name>Task 2: Build task creation and opportunity management services</name>
  <files>src/crm/tasks.ts, src/crm/opportunities.ts</files>
  <action>
**`src/crm/tasks.ts`** — Task creation for Cat and Taylor.

**Function 1: `createReviewTask(contactId: string, borrowerName: string): Promise<string>`**

Creates a task assigned to Cat to review the generated doc request checklist.

Implementation:
1. Read Cat's user ID from `crmConfig.userIds.cat`
2. Calculate due date: 1 business day from now. Simple approach: if today is Friday, due Monday; if Saturday, due Monday; otherwise, due tomorrow. Use a `addBusinessDays(date: Date, days: number): Date` helper.
3. Call `POST /contacts/{contactId}/tasks`:
```typescript
const body = {
  title: `Review doc request — ${borrowerName}`,
  body: 'Generated checklist ready for review. Check custom fields for document list. Edit and send email when ready.',
  assignedTo: crmConfig.userIds.cat,
  dueDate: addBusinessDays(new Date(), 1).toISOString(),
  completed: false,
};
```
4. Return the created task ID

If using SDK: check 04-01 summary for actual method name (may be `ghl.contacts.createTask(contactId, body)` or similar).

**Function 2: `createPreReadinessTask(contactId: string, borrowerName: string): Promise<string>`**

Creates a task assigned to Taylor notifying that all PRE documents have been received and the client is ready for budget call.

```typescript
const body = {
  title: `PRE docs complete — ${borrowerName}`,
  body: 'All PRE-approval documents have been received. Client is ready for budget call.',
  assignedTo: crmConfig.userIds.taylor,
  dueDate: addBusinessDays(new Date(), 1).toISOString(),
  completed: false,
};
```

Return the created task ID.

**Helper: `addBusinessDays(date: Date, days: number): Date`**

Export this utility. Simple implementation: add days, skip weekends (Saturday = 6, Sunday = 0).

**`src/crm/opportunities.ts`** — Pipeline stage management.

**Function 1: `upsertOpportunity(input: { contactId: string; pipelineId: string; stageId: string; name: string }): Promise<string>`**

Creates or updates an opportunity in a pipeline. Uses `POST /opportunities/upsert`:
```typescript
const body = {
  locationId: crmConfig.locationId,
  contactId: input.contactId,
  pipelineId: input.pipelineId,
  stageId: input.stageId,
  name: input.name,
  status: 'open',
};
```
Return the opportunity ID.

**Function 2: `moveToCollectingDocs(contactId: string, borrowerName: string): Promise<string>`**

Convenience function that upserts an opportunity in the "Finmo - Live Deals" pipeline at the "Collecting Documents" stage:
```typescript
return upsertOpportunity({
  contactId,
  pipelineId: PIPELINE_IDS.LIVE_DEALS,
  stageId: crmConfig.stageIds.collectingDocuments,
  name: `${borrowerName} — Doc Collection`,
});
```

**Function 3: `moveToAllDocsReceived(contactId: string, borrowerName: string): Promise<string>`**

Convenience function for moving to "All Docs Received" stage (used by Phase 8 later, but define now):
```typescript
return upsertOpportunity({
  contactId,
  pipelineId: PIPELINE_IDS.LIVE_DEALS,
  stageId: crmConfig.stageIds.allDocsReceived,
  name: `${borrowerName} — Doc Collection`,
});
```

**Error handling for both files:**
- Same error pattern as contacts.ts (CrmRateLimitError, CrmAuthError, CrmApiError)
- Task titles include borrower name (this is visible in CRM, not a log — acceptable)
- NEVER include doc details, income amounts, or other PII in task body
- If config user IDs are empty strings (not yet populated), throw a clear error: "Cat user ID not configured — run setup/fetch-ids.ts first"

Import types and config from Plan 01 files with `.js` extensions.
  </action>
  <verify>Run `npx tsc --noEmit` — both files compile. Verify exports: tasks.ts exports `createReviewTask`, `createPreReadinessTask`, `addBusinessDays`. opportunities.ts exports `upsertOpportunity`, `moveToCollectingDocs`, `moveToAllDocsReceived`.</verify>
  <done>Task service creates review tasks for Cat and PRE-readiness tasks for Taylor. Opportunity service manages pipeline stage transitions with upsert for idempotency. Both use config-driven user IDs and stage IDs. Both validate that required IDs are configured before making API calls.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. contacts.ts exports `upsertContact` and `findContactByEmail`
3. tasks.ts exports `createReviewTask`, `createPreReadinessTask`, `addBusinessDays`
4. opportunities.ts exports `upsertOpportunity`, `moveToCollectingDocs`, `moveToAllDocsReceived`
5. No Finmo-managed fields (Deal ID, Application ID, Deal Link) are ever written by our code
6. No PII in error messages or log output
7. All functions use config-driven IDs, no hardcoded IDs in business logic
</verification>

<success_criteria>
- Contact upsert uses email as dedup key and preserves Finmo-managed fields (CRM-01)
- Task creation supports both Cat (review) and Taylor (PRE-readiness) assignment (CRM-02, CRM-05)
- Opportunity management supports pipeline stage transitions for doc collection tracking
- All API calls handle errors with typed error classes
- Business day calculation works correctly for task due dates
</success_criteria>

<output>
After completion, create `.planning/phases/04-crm-integration/04-02-SUMMARY.md`
</output>

---
phase: 04-crm-integration
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/crm/checklist-mapper.ts
  - src/crm/index.ts
autonomous: true

must_haves:
  truths:
    - "GeneratedChecklist can be transformed into CRM custom field updates with correct field IDs and value formats"
    - "Missing docs list contains only document type names (no PII, no amounts, no borrower details)"
    - "PRE and FULL doc counts are computed correctly from checklist items"
    - "Doc status is set to 'In Progress' on initial checklist sync and 'PRE Complete' when PRE items are all received"
  artifacts:
    - path: "src/crm/checklist-mapper.ts"
      provides: "Pure function mapping GeneratedChecklist to CRM field updates"
      exports: ["mapChecklistToFields", "mapChecklistToDocNames", "computeDocStatus"]
    - path: "src/crm/index.ts"
      provides: "Barrel export for all CRM modules"
  key_links:
    - from: "src/crm/checklist-mapper.ts"
      to: "src/checklist/types/index.ts"
      via: "Imports GeneratedChecklist, ChecklistItem types from Phase 3"
      pattern: "import.*from.*checklist/types"
    - from: "src/crm/checklist-mapper.ts"
      to: "src/crm/config.ts"
      via: "Reads custom field IDs from config"
      pattern: "crmConfig\\.fieldIds"
---

<objective>
Build the pure function that maps a GeneratedChecklist (Phase 3 output) into CRM custom field update payloads for MyBrokerPro.

Purpose: This is the bridge between the checklist engine and the CRM. It transforms structured checklist data into the exact format GoHighLevel expects for contact custom field updates. Being a pure function, it's independently testable without any API calls. It also creates the barrel export for the entire CRM module.

Output: A checklist-to-CRM mapper module with pure transformation functions, plus the CRM barrel export.
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-crm-integration/04-RESEARCH.md
@.planning/phases/04-crm-integration/04-01-SUMMARY.md
@src/checklist/types/checklist.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build checklist-to-CRM field mapper</name>
  <files>src/crm/checklist-mapper.ts</files>
  <action>
Create `src/crm/checklist-mapper.ts` — pure functions that transform Phase 3 `GeneratedChecklist` data into CRM field update payloads.

**Function 1: `mapChecklistToFields(checklist: GeneratedChecklist, config: { fieldIds: CrmConfig['fieldIds'] }): CrmCustomFieldUpdate[]`**

This is the core mapper. Takes a GeneratedChecklist and produces an array of CRM custom field updates. Pass config as parameter (not module-level import) to keep the function pure and testable.

Implementation:
1. Flatten all client-facing items:
```typescript
const allItems = [
  ...checklist.borrowerChecklists.flatMap(bc => bc.items),
  ...checklist.propertyChecklists.flatMap(pc => pc.items),
  ...checklist.sharedItems,
];
```

2. Separate by stage:
```typescript
const preItems = allItems.filter(i => i.stage === 'PRE');
const fullItems = allItems.filter(i => i.stage === 'FULL');
```

3. Extract document names for missing docs JSON (initially ALL items are missing):
```typescript
const missingDocNames = mapChecklistToDocNames(allItems);
```

4. Build the update array:
```typescript
return [
  { id: config.fieldIds.docStatus, field_value: 'In Progress' },
  { id: config.fieldIds.preDocsTotal, field_value: preItems.length },
  { id: config.fieldIds.preDocsReceived, field_value: 0 },
  { id: config.fieldIds.fullDocsTotal, field_value: fullItems.length },
  { id: config.fieldIds.fullDocsReceived, field_value: 0 },
  { id: config.fieldIds.missingDocs, field_value: JSON.stringify(missingDocNames) },
  { id: config.fieldIds.receivedDocs, field_value: '[]' },
  { id: config.fieldIds.docRequestSent, field_value: new Date().toISOString().split('T')[0] },
];
```

**Function 2: `mapChecklistToDocNames(items: ChecklistItem[]): string[]`**

Extracts short document names from checklist items for storage in CRM LONG_TEXT field.

IMPORTANT: Use the `document` field (internal name), NOT `displayName` (which may be very long). The `document` field is shorter and more readable in the CRM UI.

```typescript
export function mapChecklistToDocNames(items: ChecklistItem[]): string[] {
  return items.map(item => item.document);
}
```

PII safety: These are document TYPE names only (e.g., "T4 (Previous Year)", "Recent pay stub"). They contain NO borrower names, income amounts, SIN numbers, or addresses.

**Function 3: `computeDocStatus(preTotal: number, preReceived: number, fullTotal: number, fullReceived: number): string`**

Pure function that determines the aggregate doc status label:
```typescript
export function computeDocStatus(
  preTotal: number,
  preReceived: number,
  fullTotal: number,
  fullReceived: number
): string {
  if (preReceived >= preTotal && fullReceived >= fullTotal) return 'All Complete';
  if (preReceived >= preTotal) return 'PRE Complete';
  if (preReceived > 0 || fullReceived > 0) return 'In Progress';
  return 'Not Started';
}
```

This function is used by Phase 8 (Tracking Integration) when updating status as docs come in. Define it now for completeness.

**Function 4: `buildChecklistSummary(checklist: GeneratedChecklist): string`**

Builds a compact text summary for task body content (used by task creation):
```typescript
export function buildChecklistSummary(checklist: GeneratedChecklist): string {
  const lines: string[] = [];
  lines.push(`Total: ${checklist.stats.totalItems - checklist.stats.internalFlags} client docs, ${checklist.stats.internalFlags} internal flags`);
  lines.push(`PRE: ${checklist.stats.preItems} | FULL: ${checklist.stats.fullItems}`);

  for (const bc of checklist.borrowerChecklists) {
    lines.push(`${bc.borrowerName}: ${bc.items.length} items`);
  }
  if (checklist.sharedItems.length > 0) {
    lines.push(`Shared: ${checklist.sharedItems.length} items`);
  }
  if (checklist.warnings.length > 0) {
    lines.push(`⚠ ${checklist.warnings.length} warning(s)`);
  }

  return lines.join('\n');
}
```

This summary is used in CRM task body — it contains only counts and borrower names (which are already visible in the CRM contact record, so not a PII concern for task body).

All functions import types from `../checklist/types/index.js` and `./types/index.js`. Use `.js` extension in imports.
  </action>
  <verify>Run `npx tsc --noEmit` — checklist-mapper.ts compiles with no errors. Verify it imports from the Phase 3 checklist types correctly.</verify>
  <done>Checklist mapper provides pure transformation functions: GeneratedChecklist to CRM field updates, item-to-doc-name extraction, doc status computation, and checklist summary for task bodies. All functions are independently testable with no API dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Create CRM barrel export</name>
  <files>src/crm/index.ts</files>
  <action>
Create `src/crm/index.ts` — barrel export that re-exports the public API of the CRM module.

Export the following from their respective modules:

```typescript
// CRM types and constants
export type {
  CrmCustomFieldUpdate,
  CrmContactUpsertInput,
  CrmTaskInput,
  CrmOpportunityInput,
} from './types/index.js';

export {
  EXISTING_FIELDS,
  FIELD_GROUP_ID,
  PIPELINE_IDS,
  LOCATION_ID,
  DOC_TRACKING_FIELD_DEFS,
} from './types/index.js';

// Configuration
export { crmConfig, validateConfig } from './config.js';
export type { CrmConfig } from './config.js';

// CRM services
export { upsertContact, findContactByEmail } from './contacts.js';
export { createReviewTask, createPreReadinessTask, addBusinessDays } from './tasks.js';
export { upsertOpportunity, moveToCollectingDocs, moveToAllDocsReceived } from './opportunities.js';

// Checklist-to-CRM mapper
export {
  mapChecklistToFields,
  mapChecklistToDocNames,
  computeDocStatus,
  buildChecklistSummary,
} from './checklist-mapper.js';
```

Do NOT export the GHL client directly (`ghl` from client.ts). Business logic should use the service functions, not the raw SDK. The client is an internal implementation detail.

Do NOT export setup scripts. They are one-time utilities, not runtime code.

Verify this barrel export doesn't pull in runtime side effects from config.ts (dotenv import). If it does, consider using a lazy initialization pattern where config is loaded on first access rather than at import time.
  </action>
  <verify>Run `npx tsc --noEmit` — barrel export compiles. Verify all expected exports are present by checking the file has imports from contacts.js, tasks.js, opportunities.js, and checklist-mapper.js.</verify>
  <done>CRM barrel export provides clean public API. Internal implementation details (GHL client, setup scripts) are not exposed. All downstream consumers can import from `../crm/index.js`.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. checklist-mapper.ts imports GeneratedChecklist from Phase 3 types
3. mapChecklistToFields produces correct CRM field update format
4. mapChecklistToDocNames extracts document names (not displayNames)
5. computeDocStatus returns correct status labels for all combinations
6. CRM barrel export re-exports all public functions and types
7. No PII (amounts, SINs, addresses) in any JSON field values or function output
</verification>

<success_criteria>
- GeneratedChecklist maps to CRM field updates with correct IDs and value formats (CRM-03 foundation)
- Missing/received docs stored as JSON arrays of document type names only (security)
- PRE/FULL doc counts correctly computed from checklist items
- Doc status labels match the SINGLE_OPTIONS picklist values created in CRM
- All CRM module exports are accessible through barrel
</success_criteria>

<output>
After completion, create `.planning/phases/04-crm-integration/04-03-SUMMARY.md`
</output>

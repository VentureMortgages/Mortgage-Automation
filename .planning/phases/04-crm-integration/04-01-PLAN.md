---
phase: 04-crm-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/crm/types/index.ts
  - src/crm/config.ts
  - src/crm/client.ts
  - src/crm/setup/create-custom-fields.ts
  - src/crm/setup/fetch-ids.ts
  - .env.example
autonomous: true

must_haves:
  truths:
    - "GHL SDK is installed and initialized with PIT authentication"
    - "All known CRM entity IDs (pipelines, existing fields, field group) are stored as typed constants"
    - "New doc tracking custom fields are defined with correct GHL data types"
    - "Setup scripts can create custom fields and fetch user/stage IDs from the live CRM"
  artifacts:
    - path: "src/crm/types/index.ts"
      provides: "CRM type definitions and constant ID maps"
      exports: ["EXISTING_FIELDS", "DOC_TRACKING_FIELDS", "PIPELINE_IDS", "LOCATION_ID", "CrmCustomFieldUpdate"]
    - path: "src/crm/client.ts"
      provides: "GHL SDK initialization with PIT token"
      exports: ["ghl"]
    - path: "src/crm/config.ts"
      provides: "Environment-loaded CRM configuration"
      exports: ["crmConfig"]
    - path: "src/crm/setup/create-custom-fields.ts"
      provides: "One-time script to create doc tracking custom fields in MyBrokerPro"
    - path: "src/crm/setup/fetch-ids.ts"
      provides: "One-time script to fetch user IDs and pipeline stage IDs"
    - path: ".env.example"
      provides: "Template for required environment variables"
      contains: "GHL_API_KEY"
  key_links:
    - from: "src/crm/client.ts"
      to: "src/crm/config.ts"
      via: "Reads API key and location ID from config"
      pattern: "import.*from.*config"
    - from: "src/crm/types/index.ts"
      to: "src/crm/config.ts"
      via: "Constants reference same location/pipeline IDs"
---

<objective>
Set up the CRM integration foundation: install the GoHighLevel SDK, define all CRM types and ID constants, create the GHL client wrapper, and build setup scripts for one-time CRM provisioning.

Purpose: Every subsequent CRM plan depends on having the SDK installed, the client configured, and the type/constant definitions in place. The setup scripts are needed to create custom fields and fetch user/stage IDs from the live CRM before the integration can work. Getting this foundation right prevents chasing ID mismatches and auth errors in later plans.

Output: Installable CRM module with typed constants, configured SDK client, and runnable setup scripts for custom field creation and ID fetching.
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-crm-integration/04-RESEARCH.md
@.planning/MBP_CRM_REFERENCE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install GHL SDK and create CRM types, constants, config, and client</name>
  <files>package.json, src/crm/types/index.ts, src/crm/config.ts, src/crm/client.ts, .env.example</files>
  <action>
**Step 1: Install dependencies**

Run:
```bash
npm install @gohighlevel/api-client dotenv
```

**Step 2: Create `.env.example`**

Template file (NO real secrets, just placeholders):
```
# GoHighLevel (MyBrokerPro) CRM Configuration
GHL_API_KEY=pit-your-private-integration-token-here
GHL_BASE_URL=https://services.leadconnectorhq.com
GHL_LOCATION_ID=bzzWH2mLpCr7HHulO3bW

# User IDs (populated by running: npx tsx src/crm/setup/fetch-ids.ts)
GHL_USER_CAT_ID=
GHL_USER_TAYLOR_ID=

# Doc Tracking Custom Field IDs (populated by running: npx tsx src/crm/setup/create-custom-fields.ts)
GHL_FIELD_DOC_STATUS_ID=
GHL_FIELD_DOC_REQUEST_SENT_ID=
GHL_FIELD_MISSING_DOCS_ID=
GHL_FIELD_RECEIVED_DOCS_ID=
GHL_FIELD_PRE_TOTAL_ID=
GHL_FIELD_PRE_RECEIVED_ID=
GHL_FIELD_FULL_TOTAL_ID=
GHL_FIELD_FULL_RECEIVED_ID=
GHL_FIELD_LAST_DOC_RECEIVED_ID=

# Pipeline Stage IDs (populated by running: npx tsx src/crm/setup/fetch-ids.ts)
GHL_STAGE_APP_RECEIVED_ID=
GHL_STAGE_COLLECTING_DOCS_ID=
GHL_STAGE_ALL_DOCS_RECEIVED_ID=
```

**Step 3: Create `src/crm/config.ts`**

Loads and validates environment variables using dotenv. Exports a `crmConfig` object:

```typescript
import 'dotenv/config';

export interface CrmConfig {
  apiKey: string;
  baseUrl: string;
  locationId: string;
  userIds: {
    cat: string;
    taylor: string;
  };
  fieldIds: {
    docStatus: string;
    docRequestSent: string;
    missingDocs: string;
    receivedDocs: string;
    preDocsTotal: string;
    preDocsReceived: string;
    fullDocsTotal: string;
    fullDocsReceived: string;
    lastDocReceived: string;
  };
  stageIds: {
    applicationReceived: string;
    collectingDocuments: string;
    allDocsReceived: string;
  };
}
```

The config reads from `process.env`. For required fields (apiKey, locationId), throw a clear error if missing. For fields that need to be fetched (user IDs, custom field IDs, stage IDs), allow empty strings — they'll be populated after running setup scripts. Add a `validateConfig()` function that checks all required fields are populated (for use at runtime, not setup time).

**Step 4: Create `src/crm/types/index.ts`**

Define typed constants and interfaces:

1. **Known IDs** (from research — these are hardcoded, already confirmed):
```typescript
export const EXISTING_FIELDS = {
  FINMO_DEAL_ID: 'YoBlMiUV8N3MrvUYoxH0',
  FINMO_APPLICATION_ID: 'FmesbQomeEwegqIyAst4',
  FINMO_DEAL_LINK: 'NhJ3BGgSZcEtyccuYkOB',
  TRANSACTION_TYPE: 'no18IIHr4smgHvfpkMHm',
  CLOSING_DATE: 'JZdgo6e5kYorFubnSMzI',
} as const;

export const FIELD_GROUP_ID = 'jlGAdTgblv5q2cWiw2Qc'; // Finmo Integration group

export const PIPELINE_IDS = {
  FINMO_LEADS: 'FK2LWevdQrcfHLHfjpDa',
  LIVE_DEALS: 'tkBeD1nIfgNphnh1oyDW',
} as const;

export const LOCATION_ID = 'bzzWH2mLpCr7HHulO3bW';
```

2. **Doc tracking field definitions** (schema for creation, IDs loaded from config at runtime):
```typescript
export const DOC_TRACKING_FIELD_DEFS = [
  { envKey: 'GHL_FIELD_DOC_STATUS_ID', name: 'Doc Collection Status', dataType: 'SINGLE_OPTIONS' as const, picklistOptions: ['Not Started', 'In Progress', 'PRE Complete', 'All Complete'] },
  { envKey: 'GHL_FIELD_DOC_REQUEST_SENT_ID', name: 'Doc Request Sent Date', dataType: 'DATE' as const },
  { envKey: 'GHL_FIELD_MISSING_DOCS_ID', name: 'Missing Docs', dataType: 'LONG_TEXT' as const },
  { envKey: 'GHL_FIELD_RECEIVED_DOCS_ID', name: 'Received Docs', dataType: 'LONG_TEXT' as const },
  { envKey: 'GHL_FIELD_PRE_TOTAL_ID', name: 'PRE Docs Total', dataType: 'NUMERICAL' as const },
  { envKey: 'GHL_FIELD_PRE_RECEIVED_ID', name: 'PRE Docs Received', dataType: 'NUMERICAL' as const },
  { envKey: 'GHL_FIELD_FULL_TOTAL_ID', name: 'FULL Docs Total', dataType: 'NUMERICAL' as const },
  { envKey: 'GHL_FIELD_FULL_RECEIVED_ID', name: 'FULL Docs Received', dataType: 'NUMERICAL' as const },
  { envKey: 'GHL_FIELD_LAST_DOC_RECEIVED_ID', name: 'Last Doc Received Date', dataType: 'DATE' as const },
] as const;
```

3. **CRM interfaces**:
```typescript
export interface CrmCustomFieldUpdate {
  id: string;
  field_value: string | number;
}

export interface CrmContactUpsertInput {
  email: string;
  firstName: string;
  lastName: string;
  phone?: string;
  customFields?: CrmCustomFieldUpdate[];
}

export interface CrmTaskInput {
  contactId: string;
  title: string;
  body?: string;
  assignedTo: string;
  dueDate: string; // ISO date string
}

export interface CrmOpportunityInput {
  contactId: string;
  pipelineId: string;
  stageId: string;
  name: string;
}
```

**Step 5: Create `src/crm/client.ts`**

Initialize the GHL SDK using PIT authentication:

```typescript
import HighLevel from '@gohighlevel/api-client';
import { crmConfig } from './config.js';

// NOTE: The SDK import/initialization may need adjustment based on
// actual SDK export structure. Check `node_modules/@gohighlevel/api-client`
// TypeScript definitions. If HighLevel is not a default export, use
// the named export (e.g., `import { HighLevel } from '...'`).
// If the SDK does not support PIT directly in constructor, configure
// the auth header manually.

const ghl = new HighLevel({
  privateIntegrationToken: crmConfig.apiKey,
});

export { ghl };
```

IMPORTANT: The exact SDK initialization may differ from the research examples. After installing `@gohighlevel/api-client`, check its actual TypeScript exports by reading `node_modules/@gohighlevel/api-client/dist/index.d.ts` or the package's main entry point. Adjust the import and initialization accordingly. If the SDK doesn't export a class constructor accepting PIT, fall back to creating a thin HTTP client wrapper using `fetch` with the PIT as Bearer token and the required `Version: 2021-07-28` header. This fallback is a perfectly acceptable approach and may actually be simpler.

Use `.js` extension in all local imports per NodeNext module resolution pattern.
  </action>
  <verify>
Run `npx tsc --noEmit` — all new CRM files compile with no errors.

Verify the SDK installed: `ls node_modules/@gohighlevel/api-client`

Verify `.env.example` exists and contains all required variable names.
  </verify>
  <done>GHL SDK (or fallback HTTP client) is installed and configured. CRM types, constants, and config are defined. All known entity IDs from CRM exploration are stored as typed constants. .env.example documents all required environment variables.</done>
</task>

<task type="auto">
  <name>Task 2: Create setup scripts for custom field creation and ID fetching</name>
  <files>src/crm/setup/create-custom-fields.ts, src/crm/setup/fetch-ids.ts</files>
  <action>
These are one-time utility scripts run manually to provision the CRM and populate .env values. They are NOT part of the runtime automation.

**`src/crm/setup/fetch-ids.ts`**

Script that fetches pipeline stage IDs and user IDs from the live CRM, then prints them in `.env` format for copy-paste.

1. Fetch pipelines via `GET /opportunities/pipelines` (or SDK equivalent)
2. Find "Finmo - Leads" pipeline (`FK2LWevdQrcfHLHfjpDa`) and extract stage ID for "Application Received"
3. Find "Finmo - Live Deals" pipeline (`tkBeD1nIfgNphnh1oyDW`) and extract stage IDs for "Collecting Documents" and "All Docs Received"
4. Fetch users via `GET /users/` (or `GET /locations/{locationId}/users`)
5. Print all users with their names and IDs (so the operator can identify Cat and Taylor)
6. Print output in this format:
```
# Pipeline Stage IDs
GHL_STAGE_APP_RECEIVED_ID=<fetched-id>
GHL_STAGE_COLLECTING_DOCS_ID=<fetched-id>
GHL_STAGE_ALL_DOCS_RECEIVED_ID=<fetched-id>

# User IDs (identify Cat and Taylor from list below)
# <Name> - <ID>
# <Name> - <ID>
GHL_USER_CAT_ID=
GHL_USER_TAYLOR_ID=
```

Use the GHL SDK if its methods work correctly, otherwise fall back to raw `fetch` calls:
```typescript
const response = await fetch(`${baseUrl}/opportunities/pipelines`, {
  headers: {
    'Authorization': `Bearer ${apiKey}`,
    'Version': '2021-07-28',
    'Content-Type': 'application/json',
  },
});
```

Handle errors with clear messages. If a stage name is not found exactly, print all stage names so the operator can find the right one.

Make the script runnable with: `npx tsx src/crm/setup/fetch-ids.ts`

**`src/crm/setup/create-custom-fields.ts`**

Script that creates the 9 doc tracking custom fields in MyBrokerPro and prints the resulting field IDs in `.env` format.

1. Import field definitions from `DOC_TRACKING_FIELD_DEFS` in types
2. For each field definition:
   a. Call `POST /locations/{locationId}/customFields` with:
      - `name`: field name
      - `dataType`: field type
      - `model`: "contact"
      - `parentId`: FIELD_GROUP_ID (Finmo Integration group)
      - `picklistOptions`: only for SINGLE_OPTIONS type
   b. Capture the returned `id` from the response
   c. Print `{envKey}={created-id}`
3. If a field already exists (409 conflict or similar error), print a warning and skip it
4. Print summary of all created field IDs in `.env` format for copy-paste

Use the GHL SDK if available, otherwise raw `fetch`:
```typescript
const response = await fetch(`${baseUrl}/locations/${locationId}/customFields`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${apiKey}`,
    'Version': '2021-07-28',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: fieldDef.name,
    dataType: fieldDef.dataType,
    model: 'contact',
    parentId: FIELD_GROUP_ID,
    ...(fieldDef.picklistOptions ? { picklistOptions: fieldDef.picklistOptions } : {}),
  }),
});
```

Make the script runnable with: `npx tsx src/crm/setup/create-custom-fields.ts`

IMPORTANT: Both scripts should load dotenv at the top. Both should print clear instructions if GHL_API_KEY is not set. Use `console.log` for output intended for the operator, `console.error` for errors.

NOTE: Install `tsx` as a dev dependency if not already present: `npm install -D tsx`
  </action>
  <verify>
Run `npx tsc --noEmit` — both setup scripts compile.

Verify scripts are syntactically correct by checking they import from the correct paths with .js extensions.

Do NOT actually run the scripts against the live CRM in this step. They will be run manually by the operator.
  </verify>
  <done>Two setup scripts exist: fetch-ids.ts prints user and stage IDs from the live CRM, create-custom-fields.ts creates 9 doc tracking fields and prints their IDs. Both output in .env format for easy copy-paste. Both handle errors gracefully.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` succeeds with zero errors
2. `@gohighlevel/api-client` and `dotenv` are in package.json dependencies
3. All known CRM IDs from MBP_CRM_REFERENCE.md are stored as typed constants
4. `.env.example` documents all required environment variables
5. Setup scripts compile and use correct API endpoints
6. No PII or real secrets in committed code
</verification>

<success_criteria>
- GHL SDK is installed and importable
- CRM types define all necessary interfaces (contact upsert, task, opportunity, custom field update)
- All confirmed CRM entity IDs are stored as typed constants
- Config module loads environment variables with validation
- Setup scripts are ready to run against the live CRM
- .env.example serves as documentation for all required configuration
</success_criteria>

<output>
After completion, create `.planning/phases/04-crm-integration/04-01-SUMMARY.md`
</output>

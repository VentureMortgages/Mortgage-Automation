---
phase: 01-webhook-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/webhook/finmo-client.ts
  - src/webhook/worker.ts
  - src/index.ts
  - src/webhook/__tests__/worker.test.ts
autonomous: true
user_setup:
  - service: npm_packages
    why: "Express 5, BullMQ, and ioredis are new dependencies for Phase 1"
    env_vars: []
    dashboard_config:
      - task: "Run npm install express bullmq ioredis && npm install -D @types/express supertest @types/supertest"
        location: "Terminal in project root"
  - service: railway
    why: "Production deployment with Redis"
    env_vars:
      - name: REDIS_URL
        source: "Railway Dashboard -> Redis service -> Connection URL"
      - name: PORT
        source: "Railway auto-provides this"
      - name: AUTOMATION_KILL_SWITCH
        source: "Set to 'false' initially in Railway variables"
      - name: FINMO_API_KEY
        source: "Finmo Team Settings -> Integrations -> REST API Key"
      - name: FINMO_RESTHOOK_PUBLIC_KEY
        source: "Finmo Team Settings -> Integrations -> Resthooks section (optional)"
    dashboard_config:
      - task: "Add Redis service to Railway project"
        location: "Railway Dashboard -> New Service -> Database -> Redis"
      - task: "Configure Finmo resthook URL to point to Railway deployment"
        location: "Finmo Team Settings -> Integrations -> Resthooks -> Add URL: https://{railway-domain}/webhooks/finmo"

must_haves:
  truths:
    - "Worker fetches full application from Finmo API when job is processed"
    - "Worker calls generateChecklist -> syncChecklistToCrm -> createEmailDraft in sequence"
    - "Worker returns ProcessingResult with applicationId, contactId, draftId, warnings, errors"
    - "Failed Finmo API calls cause job to fail and retry via BullMQ backoff"
    - "Application entry point starts Express server and BullMQ worker in single process"
    - "Graceful shutdown closes worker, queue, and server on SIGTERM/SIGINT"
  artifacts:
    - path: "src/webhook/finmo-client.ts"
      provides: "Finmo API client to fetch full application by ID"
      exports: ["fetchFinmoApplication"]
    - path: "src/webhook/worker.ts"
      provides: "BullMQ worker that orchestrates checklist -> CRM -> email pipeline"
      exports: ["createWorker", "closeWorker"]
    - path: "src/index.ts"
      provides: "Application entry point (starts server + worker)"
      contains: "app.listen"
    - path: "src/webhook/__tests__/worker.test.ts"
      provides: "Tests for worker orchestration logic"
      min_lines: 50
  key_links:
    - from: "src/webhook/worker.ts"
      to: "src/checklist/engine/index.ts"
      via: "imports generateChecklist"
      pattern: "generateChecklist"
    - from: "src/webhook/worker.ts"
      to: "src/crm/index.ts"
      via: "imports syncChecklistToCrm"
      pattern: "syncChecklistToCrm"
    - from: "src/webhook/worker.ts"
      to: "src/email/index.ts"
      via: "imports createEmailDraft"
      pattern: "createEmailDraft"
    - from: "src/webhook/worker.ts"
      to: "src/webhook/finmo-client.ts"
      via: "imports fetchFinmoApplication to get full app data"
      pattern: "fetchFinmoApplication"
    - from: "src/index.ts"
      to: "src/webhook/server.ts"
      via: "imports createApp and starts listening"
      pattern: "createApp"
    - from: "src/index.ts"
      to: "src/webhook/worker.ts"
      via: "imports createWorker and starts processing"
      pattern: "createWorker"
---

<objective>
Create the Finmo API client, BullMQ worker that orchestrates the full pipeline (fetch -> checklist -> CRM -> email), and the application entry point that starts everything in a single process.

Purpose: This is the glue that connects the webhook receiver (Plan 02) to the existing business logic modules (Phases 3-5). The worker is the core of the system — it takes an applicationId from the queue, fetches the full application from Finmo, generates the checklist, syncs to CRM, and creates an email draft. The entry point starts both the HTTP server and the worker in one process (appropriate for current scale of <10 webhooks/day).

Output: src/webhook/finmo-client.ts, src/webhook/worker.ts, src/index.ts with tests for worker orchestration.
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webhook-foundation/01-RESEARCH.md
@.planning/phases/01-webhook-foundation/01-01-SUMMARY.md
@.planning/phases/01-webhook-foundation/01-02-SUMMARY.md
@src/checklist/engine/index.ts
@src/checklist/types/index.ts
@src/crm/index.ts
@src/crm/checklist-sync.ts
@src/email/index.ts
@src/email/draft.ts
@src/email/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Finmo API client and worker orchestrator with tests</name>
  <files>src/webhook/finmo-client.ts, src/webhook/worker.ts, src/webhook/__tests__/worker.test.ts</files>
  <action>
**Create `src/webhook/finmo-client.ts`** — fetches full application from Finmo API:

```typescript
import type { FinmoApplicationResponse } from '../checklist/types/index.js';
import { appConfig } from '../config.js';
import { sanitizeForLog } from './sanitize.js';

export async function fetchFinmoApplication(applicationId: string): Promise<FinmoApplicationResponse> {
  const url = `${appConfig.finmo.apiBase}/applications/${applicationId}`;

  const response = await fetch(url, {
    headers: {
      'Authorization': `Bearer ${appConfig.finmo.apiKey}`,
      'Accept': 'application/json',
    },
  });

  if (!response.ok) {
    throw new Error(`Finmo API error: ${response.status} ${response.statusText} for application ${applicationId}`);
  }

  const data = await response.json() as FinmoApplicationResponse;

  // Log metadata only (never log raw response — contains PII)
  console.log('[finmo] Fetched application', {
    applicationId,
    borrowerCount: data.borrowers?.length ?? 0,
    goal: data.application?.goal,
    status: data.application?.applicationStatus,
  });

  return data;
}
```

Important: The Finmo API returns a `FinmoApplicationResponse` which is the type already defined in `src/checklist/types/finmo.ts`. This is the same type that `generateChecklist` accepts. Do NOT create new types — reuse existing ones.

Important: Never log the raw `data` object. Only log metadata fields that are non-PII (applicationId, borrower count, goal, status).

**Create `src/webhook/worker.ts`** — BullMQ worker that orchestrates the pipeline:

```typescript
import { Worker, Job } from 'bullmq';
import { createRedisConnection, QUEUE_NAME } from './queue.js';
import { appConfig } from '../config.js';
import { sanitizeForLog } from './sanitize.js';
import { fetchFinmoApplication } from './finmo-client.js';
import { generateChecklist } from '../checklist/engine/index.js';
import { syncChecklistToCrm } from '../crm/index.js';
import { createEmailDraft } from '../email/index.js';
import type { JobData, ProcessingResult } from './types.js';

let _worker: Worker | null = null;

async function processJob(job: Job<JobData>): Promise<ProcessingResult> {
  const { applicationId } = job.data;
  console.log(`[worker] Processing job ${job.id}`, { applicationId, attempt: job.attemptsMade + 1 });

  // Kill switch check (belt-and-suspenders — also checked at webhook layer)
  if (appConfig.killSwitch) {
    throw new Error('Automation disabled by kill switch');
  }

  // 1. Fetch full application from Finmo API
  const finmoApp = await fetchFinmoApplication(applicationId);

  // 2. Generate checklist
  const checklist = generateChecklist(finmoApp);
  console.log('[worker] Checklist generated', {
    applicationId,
    totalItems: checklist.stats.totalItems,
    borrowers: checklist.borrowerChecklists.length,
  });

  // 3. Sync to CRM
  const mainBorrower = finmoApp.borrowers.find(b => b.isMainBorrower);
  if (!mainBorrower) {
    throw new Error(`No main borrower found for application ${applicationId}`);
  }

  const crmResult = await syncChecklistToCrm({
    checklist,
    borrowerEmail: mainBorrower.email,
    borrowerFirstName: mainBorrower.firstName,
    borrowerLastName: mainBorrower.lastName,
    borrowerPhone: mainBorrower.phone ?? undefined,
    finmoDealId: applicationId,
  });

  console.log('[worker] CRM synced', {
    applicationId,
    contactId: crmResult.contactId,
    fieldsUpdated: crmResult.fieldsUpdated,
    errors: crmResult.errors.length,
  });

  // 4. Create email draft
  const emailResult = await createEmailDraft({
    checklist,
    recipientEmail: mainBorrower.email,
    borrowerFirstNames: finmoApp.borrowers.map(b => b.firstName),
    contactId: crmResult.contactId,
  });

  console.log('[worker] Email draft created', {
    applicationId,
    draftId: emailResult.draftId,
    subject: emailResult.subject,
  });

  return {
    applicationId,
    contactId: crmResult.contactId,
    draftId: emailResult.draftId,
    warnings: checklist.warnings ?? [],
    errors: crmResult.errors,
  };
}

export function createWorker(): Worker<JobData, ProcessingResult> {
  if (_worker) return _worker;

  _worker = new Worker<JobData, ProcessingResult>(QUEUE_NAME, processJob, {
    connection: createRedisConnection(),
    concurrency: 1,
  });

  _worker.on('completed', (job) => {
    console.log(`[worker] Job ${job.id} completed`, {
      applicationId: job.data.applicationId,
    });
  });

  _worker.on('failed', (job, err) => {
    console.error(`[worker] Job ${job?.id} failed`, {
      applicationId: job?.data?.applicationId,
      error: err.message,
      attempt: job?.attemptsMade,
      maxAttempts: job?.opts?.attempts,
    });
    if (job && job.attemptsMade >= (job.opts.attempts ?? 1)) {
      console.error(`[worker] Job ${job.id} exhausted all retries — now in dead-letter`, {
        applicationId: job.data.applicationId,
      });
    }
  });

  console.log('[worker] Started, listening for jobs on queue:', QUEUE_NAME);
  return _worker;
}

export async function closeWorker(): Promise<void> {
  if (_worker) {
    await _worker.close();
    _worker = null;
  }
}
```

Important notes:
- The worker logs ONLY metadata (applicationId, counts, contactId). Never log raw Finmo data.
- The `processJob` function is extracted for testability.
- `checklist.warnings` may or may not exist on the GeneratedChecklist type — check the actual type definition. If `warnings` is not on GeneratedChecklist, use an empty array or check `checklist.stats` for relevant info.
- Access `mainBorrower.phone` carefully — the FinmoBorrower type may use `phoneNumber` instead of `phone`. Check `src/checklist/types/finmo.ts` for the actual field name.

**Create `src/webhook/__tests__/worker.test.ts`** — tests for worker orchestration:

Mock ALL external dependencies (Finmo API, CRM, email, queue):

```typescript
vi.mock('../finmo-client.js', () => ({ fetchFinmoApplication: vi.fn() }));
vi.mock('../../checklist/engine/index.js', () => ({ generateChecklist: vi.fn() }));
vi.mock('../../crm/index.js', () => ({ syncChecklistToCrm: vi.fn() }));
vi.mock('../../email/index.js', () => ({ createEmailDraft: vi.fn() }));
vi.mock('../../config.js', () => ({ appConfig: { killSwitch: false, finmo: {}, redis: {} } }));
vi.mock('../queue.js', () => ({
  createRedisConnection: vi.fn(() => ({})),
  QUEUE_NAME: 'finmo-webhooks',
}));
```

Test the `processJob` function directly (export it for testing or test via the worker).

Actually, to test processJob without BullMQ, export it as a named export:
```typescript
export { processJob as _processJob }; // for testing only
```

Test cases:
1. Happy path: fetchFinmoApplication -> generateChecklist -> syncChecklistToCrm -> createEmailDraft all succeed; returns ProcessingResult with all fields populated
2. Finmo API failure: fetchFinmoApplication throws -> job fails (error propagates for BullMQ retry)
3. No main borrower: finmoApp.borrowers has no isMainBorrower=true -> throws descriptive error
4. CRM sync failure: syncChecklistToCrm throws -> job fails (error propagates)
5. Email draft failure: createEmailDraft throws -> job fails (error propagates)
6. Kill switch active: appConfig.killSwitch=true -> throws "Automation disabled by kill switch"
7. Verify pipeline order: assert fetchFinmoApplication called before generateChecklist, CRM before email

Create mock fixtures:
- Mock FinmoApplicationResponse with 1 main borrower, minimal valid data
- Mock GeneratedChecklist with stats and borrowerChecklists
- Mock SyncChecklistResult with contactId
- Mock CreateEmailDraftResult with draftId

Do NOT use real BullMQ Worker in tests. Mock the queue module entirely.
  </action>
  <verify>Run `npx vitest run src/webhook/__tests__/worker.test.ts` — all tests pass. Run `npx tsc --noEmit` — no type errors.</verify>
  <done>Worker processes jobs through full pipeline: Finmo fetch -> checklist generation -> CRM sync -> email draft. ProcessingResult returned with all metadata. Failures propagate for BullMQ retry. Kill switch checked at worker level. 7+ test cases pass with all dependencies mocked.</done>
</task>

<task type="auto">
  <name>Task 2: Create application entry point with graceful shutdown</name>
  <files>src/index.ts</files>
  <action>
Create `src/index.ts` — the application entry point that starts both the Express server and the BullMQ worker in a single process.

```typescript
import { createApp } from './webhook/server.js';
import { createWorker, closeWorker } from './webhook/worker.js';
import { closeQueue } from './webhook/queue.js';
import { appConfig } from './config.js';

async function main() {
  console.log('[startup] Venture Mortgages Doc Automation starting...');
  console.log('[startup] Environment:', appConfig.isDev ? 'development' : 'production');
  console.log('[startup] Kill switch:', appConfig.killSwitch ? 'ACTIVE' : 'inactive');

  // Start Express server
  const app = createApp();
  const server = app.listen(appConfig.server.port, () => {
    console.log(`[startup] Server listening on port ${appConfig.server.port}`);
  });

  // Start BullMQ worker
  const worker = createWorker();

  // Graceful shutdown
  const shutdown = async (signal: string) => {
    console.log(`[shutdown] Received ${signal} — shutting down gracefully...`);

    // Stop accepting new connections
    server.close(() => {
      console.log('[shutdown] HTTP server closed');
    });

    // Close worker (finish current job, stop accepting new)
    await closeWorker();
    console.log('[shutdown] Worker closed');

    // Close queue connection
    await closeQueue();
    console.log('[shutdown] Queue closed');

    process.exit(0);
  };

  process.on('SIGTERM', () => shutdown('SIGTERM'));
  process.on('SIGINT', () => shutdown('SIGINT'));
}

main().catch((err) => {
  console.error('[startup] Fatal error:', err.message);
  process.exit(1);
});
```

Key points:
- Single process: web server + worker (appropriate for <10 webhooks/day)
- Graceful shutdown on SIGTERM (Railway/Docker) and SIGINT (Ctrl+C)
- Shutdown order: stop HTTP -> close worker -> close queue
- Log startup config (isDev, killSwitch, port) for operational visibility
- main() is async to handle any startup errors

Also update `package.json` scripts to add a `start` script:
```json
"start": "node dist/index.js"
```

And add a `dev` script for local development:
```json
"dev": "tsx src/index.ts"
```

Do NOT run npm install in this task — that's in user_setup.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify package.json has start and dev scripts. Verify src/index.ts imports all modules correctly.</verify>
  <done>Entry point starts Express server and BullMQ worker in single process. Graceful shutdown handles SIGTERM/SIGINT by closing server -> worker -> queue in order. Package.json has start (production) and dev (tsx) scripts.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors across all new files
2. `npx vitest run src/webhook/__tests__/worker.test.ts` — all tests pass
3. `npx vitest run` — ALL existing tests (125+) still pass (no regressions)
4. src/index.ts imports from server.ts, worker.ts, queue.ts, config.ts
5. Worker calls fetchFinmoApplication -> generateChecklist -> syncChecklistToCrm -> createEmailDraft in sequence
6. No PII appears in any console.log/console.error statements
7. Graceful shutdown handlers registered for SIGTERM and SIGINT
8. package.json has "start" and "dev" scripts
</verification>

<success_criteria>
- Finmo client fetches application by ID with bearer token auth and returns typed FinmoApplicationResponse
- Worker orchestrates full pipeline: fetch -> checklist -> CRM sync -> email draft
- Worker returns ProcessingResult with applicationId, contactId, draftId, warnings, errors
- Entry point starts server on configured port and worker in same process
- Graceful shutdown closes all resources cleanly
- All new tests pass, all existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-webhook-foundation/01-03-SUMMARY.md`
</output>

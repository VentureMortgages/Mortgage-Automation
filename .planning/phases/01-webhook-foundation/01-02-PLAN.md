---
phase: 01-webhook-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/webhook/queue.ts
  - src/webhook/server.ts
  - src/webhook/health.ts
  - src/webhook/__tests__/server.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /webhooks/finmo returns HTTP 202 with { accepted: true, applicationId } when automation is enabled"
    - "POST /webhooks/finmo returns HTTP 503 when AUTOMATION_KILL_SWITCH=true"
    - "Duplicate webhooks with same applicationId are silently deduplicated via BullMQ jobId"
    - "GET /health returns server status, kill switch state, and timestamp"
    - "BullMQ queue is configured with exponential backoff (5 attempts, 5s base delay) and 24h job retention"
  artifacts:
    - path: "src/webhook/queue.ts"
      provides: "BullMQ queue with dedup, backoff, and dead-letter config"
      exports: ["webhookQueue", "createRedisConnection", "QUEUE_NAME"]
    - path: "src/webhook/server.ts"
      provides: "Express 5 app with webhook POST route and error handling"
      exports: ["createApp"]
    - path: "src/webhook/health.ts"
      provides: "Health check endpoint handler"
      exports: ["healthHandler"]
    - path: "src/webhook/__tests__/server.test.ts"
      provides: "Tests for webhook endpoint and health check"
      min_lines: 60
  key_links:
    - from: "src/webhook/server.ts"
      to: "src/webhook/queue.ts"
      via: "imports webhookQueue to enqueue jobs"
      pattern: "webhookQueue\\.add"
    - from: "src/webhook/server.ts"
      to: "src/config.ts"
      via: "reads killSwitch to return 503 when disabled"
      pattern: "appConfig\\.killSwitch"
    - from: "src/webhook/queue.ts"
      to: "src/config.ts"
      via: "reads Redis connection config"
      pattern: "appConfig\\.redis"
---

<objective>
Create the Express HTTP server with webhook endpoint and the BullMQ queue with deduplication and retry configuration.

Purpose: This is the core infrastructure for INFRA-01 (webhook receiver), INFRA-02 (queue + dedup), INFRA-03 (retry + dead-letter), and INFRA-06 (kill switch at HTTP layer). The server receives Finmo webhooks and enqueues them; the queue handles dedup and retry policy.

Output: src/webhook/server.ts, src/webhook/queue.ts, src/webhook/health.ts with tests for the HTTP layer.
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webhook-foundation/01-RESEARCH.md
@.planning/phases/01-webhook-foundation/01-01-SUMMARY.md
@src/config.ts
@src/webhook/types.ts
@src/webhook/sanitize.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BullMQ queue with Redis connection and dedup config</name>
  <files>src/webhook/queue.ts</files>
  <action>
Create `src/webhook/queue.ts` — BullMQ queue setup with deduplication and retry configuration.

**Redis connection factory:**
```typescript
import { Queue } from 'bullmq';
import { appConfig } from '../config.js';

export const QUEUE_NAME = 'finmo-webhooks';

export function createRedisConnection() {
  // If REDIS_URL is set (Railway provides this), use it directly
  // Otherwise fall back to host/port/password
  if (appConfig.redis.url) {
    return { url: appConfig.redis.url, maxRetriesPerRequest: null };
    // Note: BullMQ can't take a URL string directly in connection option.
    // Use ioredis to parse: new Redis(url, { maxRetriesPerRequest: null })
    // Then pass the ioredis instance as connection.
  }
  return {
    host: appConfig.redis.host,
    port: appConfig.redis.port,
    password: appConfig.redis.password,
    maxRetriesPerRequest: null,  // Required by BullMQ for blocking commands
  };
}
```

IMPORTANT: For the connection, check how BullMQ handles REDIS_URL. BullMQ's `connection` option accepts either an ioredis connection config object OR an ioredis instance. If using REDIS_URL, create a new `Redis(url, { maxRetriesPerRequest: null })` instance from ioredis and pass it. If using host/port, pass the config object directly.

**Queue creation:**
```typescript
// Lazy initialization — don't connect at import time (breaks tests)
let _queue: Queue | null = null;

export function getWebhookQueue(): Queue {
  if (!_queue) {
    _queue = new Queue(QUEUE_NAME, {
      connection: createRedisConnection(),
      defaultJobOptions: {
        attempts: 5,
        backoff: {
          type: 'exponential',
          delay: 5000,  // 5s, 10s, 20s, 40s, 80s
        },
        removeOnComplete: { age: 86400 },  // Keep 24h for dedup window
        removeOnFail: false,  // Dead-letter: keep failed jobs for manual review
      },
    });
  }
  return _queue;
}
```

Export: `QUEUE_NAME`, `createRedisConnection`, `getWebhookQueue`.

Use lazy singleton pattern (same as Gmail client in email module) — don't connect at module import time.

Also export a `closeQueue` function for graceful shutdown:
```typescript
export async function closeQueue(): Promise<void> {
  if (_queue) {
    await _queue.close();
    _queue = null;
  }
}
```
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors.</verify>
  <done>BullMQ queue module exports getWebhookQueue (lazy singleton), createRedisConnection (factory), QUEUE_NAME constant, and closeQueue (shutdown). Default job options include 5 attempts, exponential backoff from 5s, 24h retention, and failed job preservation.</done>
</task>

<task type="auto">
  <name>Task 2: Create Express server with webhook route, health check, and tests</name>
  <files>src/webhook/server.ts, src/webhook/health.ts, src/webhook/__tests__/server.test.ts</files>
  <action>
Create `src/webhook/health.ts` — simple health check handler:
```typescript
import type { Request, Response } from 'express';
import { appConfig } from '../config.js';

export function healthHandler(_req: Request, res: Response): void {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    killSwitch: appConfig.killSwitch,
    version: process.env.npm_package_version ?? 'dev',
  });
}
```

Create `src/webhook/server.ts` — Express 5 app with webhook POST route:

```typescript
import express from 'express';
import type { Request, Response, NextFunction } from 'express';
import { appConfig } from '../config.js';
import { getWebhookQueue, QUEUE_NAME } from './queue.js';
import { sanitizeForLog } from './sanitize.js';
import { healthHandler } from './health.js';
import type { WebhookPayload, JobData } from './types.js';

export function createApp() {
  const app = express();
  app.use(express.json());

  // Health check
  app.get('/health', healthHandler);

  // Finmo webhook endpoint
  app.post('/webhooks/finmo', async (req: Request, res: Response) => {
    // Kill switch check
    if (appConfig.killSwitch) {
      console.log('[webhook] Kill switch active — rejecting webhook');
      res.status(503).json({ message: 'Automation disabled' });
      return;
    }

    const payload = req.body as WebhookPayload;

    // Extract applicationId — try multiple payload shapes
    const applicationId = extractApplicationId(payload);
    if (!applicationId) {
      console.warn('[webhook] No applicationId found in payload', sanitizeForLog(payload));
      res.status(400).json({ error: 'Missing applicationId' });
      return;
    }

    // Enqueue with dedup via jobId
    const jobData: JobData = {
      applicationId,
      receivedAt: new Date().toISOString(),
    };

    const queue = getWebhookQueue();
    await queue.add('process-application', jobData, {
      jobId: `finmo-app-${applicationId}`,  // Deduplication key
    });

    console.log('[webhook] Enqueued', { applicationId, jobId: `finmo-app-${applicationId}` });
    res.status(202).json({ accepted: true, applicationId });
  });

  // Global error handler
  app.use((err: Error, _req: Request, res: Response, _next: NextFunction) => {
    console.error('[server] Unhandled error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  });

  return app;
}
```

The `extractApplicationId` helper should try multiple payload shapes since Finmo's exact resthook format is unknown:
```typescript
function extractApplicationId(payload: WebhookPayload): string | undefined {
  // Direct field
  if (typeof payload.applicationId === 'string') return payload.applicationId;
  // Nested in data
  if (payload.data && typeof (payload.data as Record<string, unknown>).applicationId === 'string') {
    return (payload.data as Record<string, unknown>).applicationId as string;
  }
  // Nested in application
  if (payload.application && typeof (payload.application as Record<string, unknown>).id === 'string') {
    return (payload.application as Record<string, unknown>).id as string;
  }
  // Field named 'id' at top level (if it looks like a UUID)
  if (typeof payload.id === 'string' && payload.id.includes('-')) return payload.id;
  return undefined;
}
```

Also export `extractApplicationId` for testing.

**Tests** at `src/webhook/__tests__/server.test.ts`:

These tests should NOT require a real Redis connection. Mock the queue module using `vi.mock`:

```typescript
import { vi, describe, it, expect, beforeEach } from 'vitest';
// Mock queue module before importing server
vi.mock('../queue.js', () => ({
  getWebhookQueue: vi.fn(() => ({
    add: vi.fn().mockResolvedValue({ id: 'test-job-id' }),
  })),
  QUEUE_NAME: 'finmo-webhooks',
}));
```

Also mock `../../../config.js` to control killSwitch:
```typescript
vi.mock('../../config.js', () => ({
  appConfig: {
    killSwitch: false,
    // ... other config
  },
}));
```

Test cases:
1. POST /webhooks/finmo with `{ applicationId: 'abc-123' }` returns 202 + `{ accepted: true, applicationId: 'abc-123' }`
2. POST /webhooks/finmo with nested `{ data: { applicationId: 'abc-123' } }` returns 202
3. POST /webhooks/finmo with `{ application: { id: 'abc-123' } }` returns 202
4. POST /webhooks/finmo with missing applicationId returns 400
5. POST /webhooks/finmo when kill switch is active returns 503
6. GET /health returns 200 with status 'ok' and killSwitch state
7. Queue.add is called with correct jobId pattern `finmo-app-{applicationId}`

Use supertest or direct app.request for HTTP testing. If supertest is not available, install it:
```bash
npm install -D supertest @types/supertest
```
Or alternatively, use the Express app directly with `app.handle(req, res)` pattern. Supertest is preferred for cleaner syntax.

Do NOT test actual Redis/BullMQ connections — those are integration tests for later. Mock the queue.
  </action>
  <verify>Run `npx vitest run src/webhook/__tests__/server.test.ts` — all tests pass. Run `npx tsc --noEmit` — no type errors.</verify>
  <done>Express app returns 202 for valid webhooks, 400 for missing applicationId, 503 when kill switch active. Health check returns status/killSwitch/timestamp. Queue.add called with dedup jobId. All assertions pass with mocked queue (no Redis needed for tests).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx vitest run src/webhook/__tests__/server.test.ts` — all tests pass
3. POST /webhooks/finmo returns 202 with accepted payload
4. POST /webhooks/finmo returns 503 when kill switch enabled
5. POST /webhooks/finmo returns 400 when no applicationId extractable
6. GET /health returns 200 with server status
7. Queue.add receives jobId: `finmo-app-{applicationId}` for deduplication
8. No PII appears in any console.log statements
</verification>

<success_criteria>
- Webhook endpoint accepts POST, extracts applicationId from multiple payload shapes, enqueues to BullMQ, returns 202
- Kill switch returns 503 and prevents enqueuing
- BullMQ queue configured with 5 retries, exponential backoff (5s base), 24h retention, failed job preservation
- Health check endpoint returns server status
- Tests pass without requiring Redis connection (mocked queue)
</success_criteria>

<output>
After completion, create `.planning/phases/01-webhook-foundation/01-02-SUMMARY.md`
</output>

---
phase: 07-classification-filing
plan: 05
type: execute
wave: 3
depends_on: ["07-02", "07-03", "07-04"]
files_modified:
  - src/classification/classification-worker.ts
  - src/classification/index.ts
  - src/intake/intake-worker.ts
  - src/classification/__tests__/classification-worker.test.ts
autonomous: true

must_haves:
  truths:
    - "Classification worker consumes jobs from the doc-classification queue and orchestrates: classify -> name -> route -> file"
    - "Low-confidence classifications create a CRM task for Cat instead of auto-filing"
    - "Intake worker writes PDF to temp file and enqueues classification job (no buffer in Redis)"
    - "Worker handles errors gracefully: classification failure, Drive failure, CRM failure all caught independently"
    - "Barrel export provides clean import surface for downstream phases"
  artifacts:
    - path: "src/classification/classification-worker.ts"
      provides: "processClassificationJob, createClassificationWorker, closeClassificationWorker, CLASSIFICATION_QUEUE_NAME"
      min_lines: 100
    - path: "src/classification/index.ts"
      provides: "Barrel export for all classification module public API"
      min_lines: 20
    - path: "src/classification/__tests__/classification-worker.test.ts"
      provides: "Tests for classification worker pipeline with mocked dependencies"
      min_lines: 80
  key_links:
    - from: "src/classification/classification-worker.ts"
      to: "src/classification/classifier.ts"
      via: "classifyDocument call"
      pattern: "classifyDocument"
    - from: "src/classification/classification-worker.ts"
      to: "src/classification/filer.ts"
      via: "uploadFile, resolveTargetFolder, findExistingFile, updateFileContent"
      pattern: "uploadFile|resolveTargetFolder"
    - from: "src/classification/classification-worker.ts"
      to: "src/classification/naming.ts"
      via: "generateFilename call"
      pattern: "generateFilename"
    - from: "src/classification/classification-worker.ts"
      to: "src/crm/contacts.ts"
      via: "findContactByEmail for client matching"
      pattern: "findContactByEmail"
    - from: "src/intake/intake-worker.ts"
      to: "src/classification/classification-worker.ts"
      via: "Enqueues ClassificationJobData to CLASSIFICATION_QUEUE_NAME"
      pattern: "CLASSIFICATION_QUEUE_NAME|classification"
---

<objective>
Build the classification worker that ties all Phase 7 modules together, update the intake worker to enqueue to the classification queue, and create the barrel export.

Purpose: This is the integration plan that wires classifier, naming, router, filer, and CRM together into a working pipeline. Also implements FILE-05 (low confidence -> manual review via CRM task). Completes the Phase 7 data flow: IntakeDocument -> temp file -> classification queue -> classify -> name -> route -> file to Drive (or CRM task for manual review).

Output: `src/classification/classification-worker.ts`, `src/classification/index.ts`, updated `src/intake/intake-worker.ts`
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-classification-filing/07-RESEARCH.md
@.planning/phases/07-classification-filing/07-01-SUMMARY.md
@.planning/phases/07-classification-filing/07-03-SUMMARY.md
@.planning/phases/07-classification-filing/07-04-SUMMARY.md
@src/classification/types.ts
@src/classification/config.ts
@src/classification/classifier.ts
@src/classification/naming.ts
@src/classification/router.ts
@src/classification/drive-client.ts
@src/classification/filer.ts
@src/intake/intake-worker.ts
@src/crm/contacts.ts
@src/crm/tasks.ts
@src/webhook/queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create classification worker with full pipeline orchestration</name>
  <files>src/classification/classification-worker.ts, src/classification/__tests__/classification-worker.test.ts</files>
  <action>
**Create `src/classification/classification-worker.ts`:**

This is the BullMQ worker that processes classification jobs. Follow the same patterns as `src/webhook/worker.ts` and `src/intake/intake-worker.ts`.

```typescript
import { readFile, unlink } from 'node:fs/promises';
import { Worker, Job } from 'bullmq';
import { createRedisConnection } from '../webhook/queue.js';
import { classificationConfig } from './config.js';
import { classifyDocument } from './classifier.js';
import { generateFilename } from './naming.js';
import { routeToSubfolder, getPersonSubfolderName } from './router.js';
import { getDriveClient } from './drive-client.js';
import { resolveTargetFolder, uploadFile, findExistingFile, updateFileContent } from './filer.js';
import { findContactByEmail } from '../crm/contacts.js';
import type { ClassificationJobData, ClassificationJobResult } from './types.js';
```

1. Export `CLASSIFICATION_QUEUE_NAME = 'doc-classification'`

2. Implement `processClassificationJob(job: Job<ClassificationJobData>): Promise<ClassificationJobResult>`:

   The pipeline:

   a. **Read PDF from temp file:**
      ```typescript
      const pdfBuffer = await readFile(job.data.tempFilePath);
      ```

   b. **Classify the document:**
      ```typescript
      const classification = await classifyDocument(pdfBuffer, job.data.originalFilename);
      ```
      Log: documentType, confidence (no PII)

   c. **Check confidence threshold:**
      If `classification.confidence < classificationConfig.confidenceThreshold`:
      - Create a CRM task for Cat for manual review (FILE-05)
      - Use existing `createReviewTask` from CRM module (import from `../crm/tasks.js`)
      - Task title: `Manual Review: ${job.data.originalFilename}`
      - Task body: `Classification uncertain (confidence: ${classification.confidence}). Best guess: ${classification.documentType}. Source: ${job.data.source}. Please review and file manually.`
      - Clean up temp file
      - Return result with `manualReview: true, filed: false`

   d. **Resolve client Drive folder:**
      - If `job.data.senderEmail`: try `findContactByEmail(senderEmail)` to get contactId
      - If contactId found: look up the contact's Drive folder ID from CRM custom field
        - For now, use a TODO comment noting that this requires a CRM custom field for Drive folder ID (to be created in Phase 8 or setup script)
        - Fallback: use `classificationConfig.driveRootFolderId` as base and search by client name
      - If `job.data.applicationId`: could look up by Finmo application ID in CRM
      - If no client folder can be resolved: create CRM task for manual review, return with `manualReview: true`

      **IMPORTANT:** For the initial implementation, use a simplified approach:
      - If there's an applicationId, try to find a matching contact via CRM
      - The client folder resolution is best-effort; if it fails, route to manual review
      - This will be refined in Phase 8 when tracking integration adds Drive folder ID to CRM

   e. **Generate filename:**
      ```typescript
      const filename = generateFilename(classification, fallbackName);
      ```
      Where fallbackName comes from classification.borrowerFirstName or job.data.originalFilename (sans extension).

   f. **Route to subfolder:**
      ```typescript
      const subfolderTarget = routeToSubfolder(classification.documentType);
      const personName = getPersonSubfolderName(
        classification.borrowerFirstName,
        classification.borrowerLastName,
        'Borrower',
      );
      ```

   g. **Resolve target folder in Drive:**
      ```typescript
      const drive = getDriveClient();
      const targetFolderId = await resolveTargetFolder(drive, clientFolderId, subfolderTarget, personName);
      ```

   h. **Check for existing file (versioning — FILE-04):**
      ```typescript
      const docLabel = DOC_TYPE_LABELS[classification.documentType] ?? classification.documentType;
      const existing = await findExistingFile(drive, docLabel, targetFolderId);
      ```

   i. **Upload or update:**
      ```typescript
      let driveFileId: string;
      if (existing) {
        await updateFileContent(drive, existing.id, pdfBuffer, filename);
        driveFileId = existing.id;
        console.log('[classification] Updated existing file:', { fileId: existing.id, filename });
      } else {
        driveFileId = await uploadFile(drive, pdfBuffer, filename, targetFolderId);
        console.log('[classification] Uploaded new file:', { fileId: driveFileId, filename });
      }
      ```

   j. **Clean up temp file:**
      ```typescript
      await unlink(job.data.tempFilePath).catch(() => {});
      ```

   k. **Return result:**
      ```typescript
      return {
        intakeDocumentId: job.data.intakeDocumentId,
        classification,
        filed: true,
        driveFileId,
        manualReview: false,
        error: null,
      };
      ```

   Wrap the entire pipeline in try/catch. On error:
   - Log error metadata (no PII)
   - Clean up temp file
   - Return result with `filed: false, error: err.message`

3. Implement lazy singleton worker (same pattern):
   ```typescript
   let _worker: Worker<ClassificationJobData, ClassificationJobResult> | null = null;

   export function createClassificationWorker(): Worker<ClassificationJobData, ClassificationJobResult> {
     if (_worker) return _worker;
     _worker = new Worker(CLASSIFICATION_QUEUE_NAME, processClassificationJob, {
       connection: createRedisConnection(),
       concurrency: 1,
     });
     // completed/failed event handlers (same pattern as intake-worker.ts)
     return _worker;
   }

   export async function closeClassificationWorker(): Promise<void> {
     if (_worker) { await _worker.close(); _worker = null; }
   }
   ```

**Create `src/classification/__tests__/classification-worker.test.ts`:**

Mock all external dependencies:
- `classifyDocument` -> returns mock ClassificationResult
- `generateFilename` -> returns mock filename
- `routeToSubfolder` -> returns mock SubfolderTarget
- `getDriveClient` -> returns mock drive client
- `resolveTargetFolder` -> returns mock folder ID
- `uploadFile` -> returns mock file ID
- `findExistingFile` -> returns null (no existing)
- `findContactByEmail` -> returns mock contact ID
- `readFile` / `unlink` from `node:fs/promises`

Test cases:
1. **Full pipeline success:** Classify -> name -> route -> upload. Assert driveFileId returned, filed=true.
2. **Low confidence -> manual review:** Classification confidence 0.3. Assert CRM task created, filed=false, manualReview=true.
3. **Existing file found -> update instead of upload:** findExistingFile returns a file. Assert updateFileContent called (not uploadFile).
4. **Classification error -> caught gracefully:** classifyDocument throws. Assert error in result, filed=false.
5. **Drive upload error -> caught gracefully:** uploadFile throws. Assert error in result.
6. **Temp file cleaned up after success:** Assert unlink called with tempFilePath.
7. **Temp file cleaned up after error:** Assert unlink called even when pipeline fails.
8. **Missing client folder -> manual review:** No contactId found, no Drive folder. Assert manualReview=true.

Use vi.mock for all dependencies. Use vi.hoisted() for shared mock variables.
  </action>
  <verify>`npm test -- --run src/classification/__tests__/classification-worker.test.ts` passes. `npx tsc --noEmit` passes.</verify>
  <done>Classification worker orchestrates the full pipeline: read temp file -> classify -> check confidence -> name -> route -> file to Drive (or manual review). Error handling is per-stage. Temp files cleaned up. Tests pass with all mocked deps.</done>
</task>

<task type="auto">
  <name>Task 2: Update intake worker to enqueue to classification queue and create barrel export</name>
  <files>src/intake/intake-worker.ts, src/classification/index.ts</files>
  <action>
**Update `src/intake/intake-worker.ts`:**

The intake worker currently logs IntakeDocuments and discards them (Phase 6 decision: "Phase 7 will consume them via classification queue"). Now wire it up:

1. Add imports:
   ```typescript
   import { writeFile } from 'node:fs/promises';
   import { join } from 'node:path';
   import { tmpdir } from 'node:os';
   import { randomUUID } from 'node:crypto';
   import { Queue } from 'bullmq';
   import { CLASSIFICATION_QUEUE_NAME } from '../classification/classification-worker.js';
   import type { ClassificationJobData } from '../classification/types.js';
   ```

2. Add a lazy singleton for the classification queue:
   ```typescript
   let _classificationQueue: Queue<ClassificationJobData> | null = null;

   function getClassificationQueue(): Queue<ClassificationJobData> {
     if (_classificationQueue) return _classificationQueue;
     _classificationQueue = new Queue(CLASSIFICATION_QUEUE_NAME, {
       connection: createRedisConnection(),
     });
     return _classificationQueue;
   }

   export async function closeClassificationQueue(): Promise<void> {
     if (_classificationQueue) {
       await _classificationQueue.close();
       _classificationQueue = null;
     }
   }
   ```

3. After the `documents.push(doc)` line in `processGmailSource`, add enqueue logic:
   ```typescript
   // Write PDF to temp file (buffers must NOT go in Redis)
   const tempFilePath = join(tmpdir(), `intake-${randomUUID()}.pdf`);
   await writeFile(tempFilePath, pdfBuffer);

   // Enqueue for classification (Phase 7)
   const classificationJob: ClassificationJobData = {
     intakeDocumentId: doc.id,
     tempFilePath,
     originalFilename: doc.originalFilename,
     senderEmail: doc.senderEmail,
     applicationId: doc.applicationId,
     source: doc.source,
     receivedAt: doc.receivedAt,
   };

   await getClassificationQueue().add(
     'classify-doc',
     classificationJob,
     { jobId: `classify-${doc.id}` },
   );
   ```

4. Do the same for `processFinmoSource` — after creating each IntakeDocument, write temp file and enqueue to classification queue.

5. Add `closeClassificationQueue` to the barrel export in `src/intake/index.ts`.

**Create `src/classification/index.ts`:**

Barrel export for the entire classification module:

```typescript
// Types (type-only exports)
export type {
  DocumentType,
  ClassificationResult,
  SubfolderTarget,
  FilingDecision,
  ClassificationJobData,
  ClassificationJobResult,
} from './types.js';

// Constants
export {
  DOCUMENT_TYPES,
  SUBFOLDER_ROUTING,
  DOC_TYPE_LABELS,
  ClassificationResultSchema,
} from './types.js';

// Config
export { classificationConfig } from './config.js';
export type { ClassificationConfig } from './config.js';

// Classifier
export { classifyDocument } from './classifier.js';

// Naming
export { generateFilename, sanitizeFilename } from './naming.js';

// Router
export { routeToSubfolder, getPersonSubfolderName } from './router.js';

// Drive client
export { getDriveClient } from './drive-client.js';
export type { DriveClient } from './drive-client.js';

// Filer
export {
  findFolder,
  findOrCreateFolder,
  uploadFile,
  findExistingFile,
  updateFileContent,
  resolveTargetFolder,
} from './filer.js';

// Classification worker
export {
  CLASSIFICATION_QUEUE_NAME,
  processClassificationJob,
  createClassificationWorker,
  closeClassificationWorker,
} from './classification-worker.js';
```

Verify the barrel compiles and all exports resolve.
  </action>
  <verify>`npm test` passes (all tests). `npx tsc --noEmit` passes. `src/classification/index.ts` exists and exports all public API.</verify>
  <done>Intake worker writes PDFs to temp files and enqueues classification jobs. Classification barrel exports all public API. The full pipeline is wired: Gmail/Finmo intake -> temp file -> classification queue -> classify -> name -> route -> file to Drive. All tests pass.</done>
</task>

</tasks>

<verification>
1. `npm test` passes (all existing + new tests)
2. `npx tsc --noEmit` passes
3. Classification worker processes jobs from doc-classification queue
4. Low-confidence documents route to CRM manual review task (FILE-05)
5. Existing files are updated instead of duplicated (FILE-04)
6. Intake worker enqueues to classification queue (no buffer in Redis — temp file path only)
7. Barrel export provides clean import surface for Phase 8
8. Temp files are cleaned up after processing
</verification>

<success_criteria>
- Full pipeline works: intake -> temp file -> classify -> name -> route -> file to Drive
- Low-confidence classifications create CRM manual review task
- Re-uploads update existing files (versioning)
- Errors at any stage are caught without crashing the worker
- Temp files are cleaned up in all code paths (success and error)
- Barrel export covers all public API
</success_criteria>

<output>
After completion, create `.planning/phases/07-classification-filing/07-05-SUMMARY.md`
</output>

---
phase: 07-classification-filing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/intake/finmo-downloader.ts
  - src/intake/intake-worker.ts
  - src/intake/index.ts
  - src/intake/__tests__/finmo-downloader.test.ts
autonomous: true

must_haves:
  truths:
    - "Finmo document download fetches files via confirmed API endpoints (list doc requests, get detail, get signed URL, download)"
    - "processFinmoSource in intake-worker produces IntakeDocument objects from Finmo document requests"
    - "Previously-downloaded Finmo documents are deduplicated via Redis set"
    - "Failed Finmo downloads are caught per-file without failing the entire job"
  artifacts:
    - path: "src/intake/finmo-downloader.ts"
      provides: "listDocRequests, getDocRequestDetail, downloadFinmoDocument, getProcessedDocRequestIds, markDocRequestProcessed"
      min_lines: 80
    - path: "src/intake/__tests__/finmo-downloader.test.ts"
      provides: "Tests for Finmo document download and dedup logic"
      min_lines: 60
  key_links:
    - from: "src/intake/finmo-downloader.ts"
      to: "src/config.ts"
      via: "appConfig.finmo.apiBase and appConfig.finmo.apiKey"
      pattern: "appConfig\\.finmo"
    - from: "src/intake/intake-worker.ts"
      to: "src/intake/finmo-downloader.ts"
      via: "import and call download functions"
      pattern: "finmo-downloader"
---

<objective>
Implement the Finmo document download pipeline that was stubbed in Phase 6. Uses confirmed Finmo API endpoints to list document requests, detect which have files, download via signed URLs, and convert to IntakeDocument objects.

Purpose: Completes INTAKE-02 (detect client Finmo uploads). The stub in `processFinmoSource` currently returns a not-implemented error. This plan implements the actual download logic using the confirmed API endpoints: GET /document-requests, GET /document-requests/{id}, GET /documents/application-document.

Output: `src/intake/finmo-downloader.ts`, updated `src/intake/intake-worker.ts`, tests
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-classification-filing/07-RESEARCH.md
@src/intake/intake-worker.ts
@src/intake/types.ts
@src/intake/config.ts
@src/intake/index.ts
@src/config.ts
@src/webhook/finmo-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create finmo-downloader module with download and dedup logic</name>
  <files>src/intake/finmo-downloader.ts, src/intake/__tests__/finmo-downloader.test.ts</files>
  <action>
**Create `src/intake/finmo-downloader.ts`:**

This module handles downloading documents from the Finmo API. Follow the same fetch+auth pattern as `src/webhook/finmo-client.ts` (bearer token from appConfig.finmo.apiKey).

1. Define internal types for Finmo document API responses:

```typescript
interface FinmoDocRequestFile {
  src: string;
  fileName: string;
  mimeType?: string;
}

interface FinmoDocRequest {
  id: string;
  name: string;
  numberOfFiles: number;
  files?: FinmoDocRequestFile[];
}
```

Use defensive parsing throughout (fields may be missing/different shape — see pitfall 6 in research).

2. Implement `listDocRequests(applicationId: string): Promise<FinmoDocRequest[]>`:
   - GET `${appConfig.finmo.apiBase}/document-requests?applicationId=${applicationId}`
   - Headers: `Authorization: Bearer ${appConfig.finmo.apiKey}`
   - Return the response parsed as `FinmoDocRequest[]`
   - Defensive: if response is not an array, return empty array
   - Log metadata only: applicationId, count of doc requests returned

3. Implement `getDocRequestDetail(docRequestId: string): Promise<FinmoDocRequest>`:
   - GET `${appConfig.finmo.apiBase}/document-requests/${docRequestId}`
   - Headers: same
   - Return parsed `FinmoDocRequest`
   - Throw on non-OK response

4. Implement `getSignedDownloadUrl(fileSrc: string): Promise<string>`:
   - GET `${appConfig.finmo.apiBase}/documents/application-document?src=${encodeURIComponent(fileSrc)}`
   - Headers: same
   - Parse response, extract `url` field (or `signedUrl` or `downloadUrl` — check multiple fields defensively)
   - Return the signed URL string

5. Implement `downloadFinmoFile(signedUrl: string): Promise<Buffer>`:
   - GET the signed URL (no auth header needed — it's a signed URL)
   - Return `Buffer.from(await response.arrayBuffer())`
   - Throw on non-OK response

6. Implement `downloadFinmoDocument(applicationId: string, docRequestId: string): Promise<FinmoDownloadResult[]>`:
   - This is the main orchestrator function
   - Get doc request detail via `getDocRequestDetail(docRequestId)`
   - If `numberOfFiles === 0` or no `files` array, return empty array
   - For each file in `files`:
     - Get signed URL via `getSignedDownloadUrl(file.src)`
     - Download the file via `downloadFinmoFile(signedUrl)`
     - Return `{ buffer, filename: file.fileName, mimeType: file.mimeType ?? 'application/octet-stream' }`
   - Catch errors per-file (don't fail the whole batch)

   Define the result type:
   ```typescript
   export interface FinmoDownloadResult {
     buffer: Buffer;
     filename: string;
     mimeType: string;
   }
   ```

7. Implement Redis-based dedup for processed document requests:
   - `isDocRequestProcessed(docRequestId: string): Promise<boolean>` — checks Redis set `finmo:processed-docs`
   - `markDocRequestProcessed(docRequestId: string): Promise<void>` — adds to Redis set

   Use ioredis with the same connection pattern as `gmail-monitor.ts` (import `{ Redis as IORedis }` from `'ioredis'`, create connection from appConfig.redis).

   If Redis is unavailable, fall back gracefully (log warning, treat as not processed).

8. Export all public functions from the module.

**Create `src/intake/__tests__/finmo-downloader.test.ts`:**

Test the Finmo downloader with mocked fetch and Redis:

1. Mock `global.fetch` using vi.fn() for API call tests
2. Mock ioredis using the same class-mock pattern from `gmail-monitor.test.ts` (vi.mock('ioredis', ...))
3. Mock `../config.js` to avoid loading real env vars (return test appConfig with finmo.apiBase = 'https://test.finmo.ca/api/v1')

Tests:
- `listDocRequests`: returns parsed array; handles empty response; handles non-array response
- `getDocRequestDetail`: returns parsed detail; throws on non-OK
- `getSignedDownloadUrl`: extracts url field; tries fallback fields
- `downloadFinmoFile`: returns Buffer from arrayBuffer
- `downloadFinmoDocument`: orchestrates detail -> signed URL -> download for each file; skips files with numberOfFiles=0; catches per-file errors
- `isDocRequestProcessed` / `markDocRequestProcessed`: checks and adds to Redis set

Use `vi.hoisted()` for mock variables shared between factory and tests (project pattern).
  </action>
  <verify>`npm test -- --run src/intake/__tests__/finmo-downloader.test.ts` passes. `npx tsc --noEmit` passes.</verify>
  <done>finmo-downloader.ts exports all download and dedup functions. Tests cover happy path, empty responses, per-file error handling, and Redis dedup. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement processFinmoSource in intake-worker and update barrel</name>
  <files>src/intake/intake-worker.ts, src/intake/index.ts</files>
  <action>
**Update `src/intake/intake-worker.ts`:**

Replace the stub `processFinmoSource` function with a real implementation:

1. Add imports at top:
   ```typescript
   import { downloadFinmoDocument, isDocRequestProcessed, markDocRequestProcessed } from './finmo-downloader.js';
   import { getConversionStrategy } from './config.js';  // already imported
   import { convertToPdf, ConversionError } from './pdf-converter.js';  // already imported
   ```

2. Replace the stub `processFinmoSource` with:

```typescript
async function processFinmoSource(job: Job<IntakeJobData>): Promise<IntakeResult> {
  const { applicationId, documentRequestId } = job.data;
  if (!documentRequestId) {
    return {
      documentsProcessed: 0,
      documentIds: [],
      errors: ['Finmo source job missing documentRequestId'],
    };
  }

  // Dedup check: skip if already processed
  const alreadyProcessed = await isDocRequestProcessed(documentRequestId);
  if (alreadyProcessed) {
    console.log('[intake] Finmo doc request already processed, skipping:', { documentRequestId });
    return { documentsProcessed: 0, documentIds: [], errors: [] };
  }

  const errors: string[] = [];
  const documentIds: string[] = [];
  const documents: IntakeDocument[] = [];

  try {
    // Download files from Finmo
    const downloadResults = await downloadFinmoDocument(
      applicationId ?? '',
      documentRequestId,
    );

    if (downloadResults.length === 0) {
      console.log('[intake] Finmo doc request has no files:', { documentRequestId });
      // Still mark as processed to avoid re-checking
      await markDocRequestProcessed(documentRequestId);
      return { documentsProcessed: 0, documentIds: [], errors: [] };
    }

    for (let index = 0; index < downloadResults.length; index++) {
      const file = downloadResults[index];
      try {
        // Determine conversion strategy
        const strategy = getConversionStrategy(file.mimeType);
        let pdfBuffer: Buffer;

        if (strategy === 'unsupported') {
          errors.push(`Unsupported MIME type from Finmo: ${file.mimeType} (${file.filename})`);
          continue;
        }

        // Convert to PDF if needed
        const conversion = await convertToPdf(file.buffer, file.mimeType);
        pdfBuffer = conversion.pdfBuffer;

        // Create IntakeDocument
        const doc: IntakeDocument = {
          id: `finmo-${documentRequestId}-${index}`,
          pdfBuffer,
          originalFilename: file.filename,
          originalMimeType: file.mimeType,
          source: 'finmo',
          senderEmail: null,
          applicationId: applicationId ?? null,
          gmailMessageId: null,
          receivedAt: job.data.receivedAt,
        };

        documents.push(doc);
        documentIds.push(doc.id);

        console.log('[intake] Produced IntakeDocument from Finmo:', {
          id: doc.id,
          source: doc.source,
          originalFilename: doc.originalFilename,
          applicationId: doc.applicationId,
        });
      } catch (err) {
        if (err instanceof ConversionError) {
          errors.push(`${err.code}: ${file.filename} — ${err.message}`);
        } else {
          errors.push(`Failed to process Finmo file ${file.filename}: ${err instanceof Error ? err.message : String(err)}`);
        }
      }
    }
  } catch (err) {
    errors.push(`Finmo download failed: ${err instanceof Error ? err.message : String(err)}`);
  }

  // Mark as processed (even with partial errors, we don't want to re-process)
  if (documentIds.length > 0 || errors.length > 0) {
    await markDocRequestProcessed(documentRequestId);
  }

  console.log(
    `[intake] Processed Finmo doc request ${documentRequestId}: ${documents.length} docs, ${errors.length} errors`,
  );

  return {
    documentsProcessed: documents.length,
    documentIds,
    errors,
  };
}
```

**Update `src/intake/index.ts` barrel:**

Add finmo-downloader exports to the barrel:

```typescript
// Finmo document download
export {
  downloadFinmoDocument,
  isDocRequestProcessed,
  markDocRequestProcessed,
} from './finmo-downloader.js';
export type { FinmoDownloadResult } from './finmo-downloader.js';
```

Add these after the existing finmo-docs export line.
  </action>
  <verify>`npm test` passes (all existing tests + new finmo-downloader tests). `npx tsc --noEmit` passes. The processFinmoSource function is no longer a stub.</verify>
  <done>processFinmoSource downloads Finmo documents via confirmed API endpoints, converts to PDF, produces IntakeDocuments, and marks document requests as processed in Redis for dedup. Per-file errors are caught without failing the whole job. Barrel exports updated.</done>
</task>

</tasks>

<verification>
1. `npm test` passes (241+ tests)
2. `npx tsc --noEmit` passes
3. `src/intake/finmo-downloader.ts` exports download functions and Redis dedup helpers
4. `src/intake/intake-worker.ts` processFinmoSource is a real implementation (not a stub)
5. New tests cover: Finmo API calls, signed URL download, per-file error handling, Redis dedup
</verification>

<success_criteria>
- Finmo document download uses confirmed API endpoints (GET /document-requests, GET /document-requests/{id}, GET /documents/application-document)
- Documents are converted to PDF using existing convertToPdf
- Redis dedup prevents re-processing the same document request
- Per-file errors don't crash the whole job
- Barrel export updated with new public functions
</success_criteria>

<output>
After completion, create `.planning/phases/07-classification-filing/07-02-SUMMARY.md`
</output>

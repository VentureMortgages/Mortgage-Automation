---
phase: 08-tracking-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/crm/contacts.ts
  - src/crm/notes.ts
  - src/crm/types/index.ts
  - src/crm/doc-type-matcher.ts
  - src/crm/checklist-mapper.ts
  - src/crm/__tests__/doc-type-matcher.test.ts
  - src/crm/__tests__/notes.test.ts
  - src/crm/__tests__/contacts.test.ts
autonomous: true

must_haves:
  truths:
    - "getContact() retrieves a CRM contact's full record including custom field values"
    - "createAuditNote() creates a timestamped note on a contact visible in CRM timeline"
    - "findMatchingChecklistDoc() correctly maps classifier DocumentType to the matching checklist document name in missingDocs"
    - "missingDocs stored in CRM includes stage information (PRE/FULL) for each document so counters can be updated correctly"
  artifacts:
    - path: "src/crm/contacts.ts"
      provides: "getContact() function to read contact with custom fields"
      contains: "getContact"
    - path: "src/crm/notes.ts"
      provides: "createAuditNote() for audit trail per TRACK-02"
      contains: "createAuditNote"
    - path: "src/crm/doc-type-matcher.ts"
      provides: "findMatchingChecklistDoc() mapping DocumentType to checklist doc names"
      contains: "findMatchingChecklistDoc"
    - path: "src/crm/types/index.ts"
      provides: "CrmContact interface, MissingDocEntry type with stage"
      contains: "CrmContact"
    - path: "src/crm/checklist-mapper.ts"
      provides: "Updated mapChecklistToFields storing {name, stage} in missingDocs"
      contains: "MissingDocEntry"
  key_links:
    - from: "src/crm/doc-type-matcher.ts"
      to: "src/classification/types.ts"
      via: "imports DOC_TYPE_LABELS and DocumentType"
      pattern: "DOC_TYPE_LABELS"
    - from: "src/crm/notes.ts"
      to: "GHL API"
      via: "POST /contacts/:contactId/notes"
      pattern: "noteFetch.*contacts.*notes"
---

<objective>
Add CRM read operations (getContact), contact notes for audit trail (TRACK-02), and doc-type matcher that bridges classifier output to checklist document names â€” the three building blocks the tracking sync orchestrator needs in Plan 02.

Purpose: Plan 02's updateDocTracking() needs to: (a) read current custom field values, (b) match classified doc types to checklist names, (c) determine PRE/FULL stage for counter updates, (d) write audit notes. This plan provides all those primitives.

Output: New modules (notes.ts, doc-type-matcher.ts), updated contacts.ts with getContact(), updated checklist-mapper.ts with stage-aware missingDocs format, and tests for all new code.
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-tracking-integration/08-RESEARCH.md
@src/crm/contacts.ts
@src/crm/types/index.ts
@src/crm/config.ts
@src/crm/errors.ts
@src/crm/checklist-mapper.ts
@src/classification/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CRM types, getContact(), notes module, and update missingDocs format</name>
  <files>
    src/crm/types/index.ts
    src/crm/contacts.ts
    src/crm/notes.ts
    src/crm/checklist-mapper.ts
  </files>
  <action>
**1. Add types to `src/crm/types/index.ts`:**

Add a `CrmContact` interface:
```typescript
export interface CrmContact {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  customFields: Array<{ id: string; value: unknown }>;
}
```

Add a `MissingDocEntry` type for structured missingDocs storage:
```typescript
export interface MissingDocEntry {
  name: string;
  stage: 'PRE' | 'FULL' | 'LATER' | 'CONDITIONAL';
}
```

Add a `CrmNoteInput` interface:
```typescript
export interface CrmNoteInput {
  documentType: string;
  source: string;
  driveFileId: string;
}
```

**2. Add `getContact()` to `src/crm/contacts.ts`:**

Add a new exported function after `findContactByEmail()`:
```typescript
export async function getContact(contactId: string): Promise<CrmContact> {
  const response = await crmFetch(`/contacts/${contactId}`, { method: 'GET' });
  const data = (await response.json()) as { contact: CrmContact };
  return data.contact;
}
```

Import `CrmContact` from `./types/index.js`. The `crmFetch` helper already exists in the same file.

**3. Create `src/crm/notes.ts`:**

Create a new module following the same pattern as contacts.ts and tasks.ts:
- Import `crmConfig` from `./config.js`
- Import `CrmApiError`, `CrmAuthError`, `CrmRateLimitError` from `./errors.js`
- Import `CrmNoteInput` from `./types/index.js`

Create `noteFetch()` internal HTTP helper (identical pattern to `crmFetch` in contacts.ts and `taskFetch` in tasks.ts â€” Authorization bearer, Version header, Content-Type JSON, same error classification).

Create exported `createAuditNote()`:
```typescript
export async function createAuditNote(
  contactId: string,
  data: CrmNoteInput,
): Promise<string> {
  const noteBody = [
    `ðŸ“„ Document received: ${data.documentType}`,
    `Source: ${data.source}`,
    `Filed to Drive: ${data.driveFileId}`,
    `Received: ${new Date().toISOString()}`,
    '',
    '[Automated by Venture Mortgages Doc System]',
  ].join('\n');

  const response = await noteFetch(`/contacts/${contactId}/notes`, {
    method: 'POST',
    body: JSON.stringify({ body: noteBody, userId: crmConfig.userIds.cat }),
  });

  const result = (await response.json()) as { note: { id: string } };
  return result.note.id;
}
```

Note: Include `userId` in the note body so it shows as created by Cat's account in the CRM.

**4. Update `mapChecklistToFields()` in `src/crm/checklist-mapper.ts`:**

Change the missingDocs field value from a flat string array to a `MissingDocEntry[]` array. This is backward-compatible because the field is LARGE_TEXT (stores any JSON string).

Import `MissingDocEntry` from `./types/index.js`.

Update the `mapChecklistToDocNames()` function to return `MissingDocEntry[]`:
```typescript
export function mapChecklistToDocEntries(items: ChecklistItem[]): MissingDocEntry[] {
  return items.map((item) => ({
    name: item.document,
    stage: item.stage,
  }));
}
```

Keep the old `mapChecklistToDocNames()` function but mark it as deprecated (it's used in tests). Or better: keep `mapChecklistToDocNames` as-is (returns `string[]`) since it's used by `buildChecklistSummary`. Add the new `mapChecklistToDocEntries` alongside it.

In `mapChecklistToFields()`, change the `missingDocs` field value from:
```typescript
{ id: config.fieldIds.missingDocs, field_value: JSON.stringify(missingDocNames) }
```
to:
```typescript
{ id: config.fieldIds.missingDocs, field_value: JSON.stringify(mapChecklistToDocEntries(allItems)) }
```

This stores `[{"name":"T4 â€” Current year","stage":"PRE"},...]` instead of `["T4 â€” Current year",...]`.

IMPORTANT: Do NOT change the `receivedDocs` field â€” it stays as `'[]'` (will be populated by tracking sync as docs arrive, using same `MissingDocEntry` format).
  </action>
  <verify>
    Run `npx tsc --noEmit` â€” zero type errors.
    Run `npx vitest run` â€” all existing tests pass (the checklist-mapper tests may need minor updates for the new missingDocs format).
  </verify>
  <done>
    - `getContact()` exists in contacts.ts and returns `CrmContact` with customFields array
    - `createAuditNote()` exists in notes.ts and POSTs to `/contacts/:contactId/notes`
    - `MissingDocEntry` type exists in types/index.ts with `name` and `stage` fields
    - `mapChecklistToDocEntries()` exists and returns `MissingDocEntry[]`
    - `mapChecklistToFields()` stores structured `MissingDocEntry[]` in missingDocs field
    - All existing tests still pass (fix any format change breakage in checklist-mapper tests)
  </done>
</task>

<task type="auto">
  <name>Task 2: Build doc-type matcher with tests and notes/contacts tests</name>
  <files>
    src/crm/doc-type-matcher.ts
    src/crm/__tests__/doc-type-matcher.test.ts
    src/crm/__tests__/notes.test.ts
    src/crm/__tests__/contacts.test.ts
  </files>
  <action>
**1. Create `src/crm/doc-type-matcher.ts`:**

This module bridges classifier output (DocumentType enum like `pay_stub`, `t4`) to checklist document names stored in CRM missingDocs (like `"Recent paystub (within 30 days)"`, `"T4 â€” Current year"`).

Import `DocumentType` and `DOC_TYPE_LABELS` from `../classification/types.js`.
Import `MissingDocEntry` from `./types/index.js`.

**Primary matching strategy â€” label prefix match (case-insensitive):**

```typescript
export function findMatchingChecklistDoc(
  documentType: DocumentType,
  missingDocs: MissingDocEntry[],
): MissingDocEntry | null {
  const label = DOC_TYPE_LABELS[documentType];
  if (!label) return null;

  const labelLower = label.toLowerCase();

  // 1. Try exact start-of-string match (covers most cases)
  const match = missingDocs.find(doc =>
    doc.name.toLowerCase().startsWith(labelLower)
  );
  if (match) return match;

  // 2. Try contains match (for cases like "Government-issued photo ID" matching label "ID")
  // Only for labels >= 3 chars to avoid false positives
  if (labelLower.length >= 3) {
    const containsMatch = missingDocs.find(doc =>
      doc.name.toLowerCase().includes(labelLower)
    );
    if (containsMatch) return containsMatch;
  }

  // 3. Try KNOWN_ALIASES for tricky mappings
  const aliases = KNOWN_ALIASES[documentType];
  if (aliases) {
    for (const alias of aliases) {
      const aliasLower = alias.toLowerCase();
      const aliasMatch = missingDocs.find(doc =>
        doc.name.toLowerCase().includes(aliasLower)
      );
      if (aliasMatch) return aliasMatch;
    }
  }

  return null;
}
```

Build `KNOWN_ALIASES` as a `Partial<Record<DocumentType, string[]>>` for known mismatches between classifier labels and checklist document names:
```typescript
const KNOWN_ALIASES: Partial<Record<DocumentType, string[]>> = {
  pay_stub: ['paystub', 'pay stub'],
  loe: ['letter of employment', 'employment letter'],
  noa: ['notice of assessment', 'NOA'],
  t1: ['T1 General'],
  photo_id: ['photo ID', 'government-issued'],
  second_id: ['second form of ID', 'second ID'],
  void_cheque: ['void cheque', 'direct deposit'],
  bank_statement: ['bank statement', '90-day bank'],
  purchase_agreement: ['purchase agreement', 'agreement of purchase'],
  pr_card: ['PR card', 'permanent resident'],
  financial_statement: ['financial statement'],
  articles_of_incorporation: ['articles of incorporation'],
  pension_letter: ['pension letter', 'pension benefit'],
  employment_contract: ['employment contract'],
  commission_statement: ['commission statement'],
  lease_agreement: ['lease agreement'],
  property_tax_bill: ['property tax'],
  mortgage_statement: ['mortgage statement'],
  home_insurance: ['home insurance'],
  separation_agreement: ['separation agreement', 'separation/divorce'],
  discharge_certificate: ['discharge certificate', 'bankruptcy discharge'],
  passport: ['passport'],
  work_permit: ['work permit'],
};
```

**2. Create `src/crm/__tests__/doc-type-matcher.test.ts`:**

Test cases (aim for 12-15 tests):
- `pay_stub` matches `"Recent paystub (within 30 days)"` â€” label prefix match with slight spelling variation handled by alias
- `t4` matches `"T4 â€” Current year"` and `"T4 â€” Previous year"` (returns first match)
- `loe` matches `"Letter of Employment"` â€” alias match
- `noa` matches `"NOA â€” Previous year"` â€” label prefix match
- `photo_id` matches `"Government-issued photo ID (front + back)"` â€” alias match
- `bank_statement` matches `"90-day bank statements"` â€” alias contains match
- `void_cheque` matches `"Void cheque or direct deposit form"` â€” label prefix match
- `purchase_agreement` matches `"Purchase agreement"` â€” label prefix match
- `pr_card` matches `"PR card"` â€” label prefix match
- `other` returns null when no match (DocumentType 'other' label is 'Document', unlikely to match)
- Empty missingDocs array returns null
- DocumentType not in missingDocs returns null
- Returned match includes correct `stage` field

Use real checklist document names from the rule files (copy exact strings).

**3. Create `src/crm/__tests__/notes.test.ts`:**

Mock the fetch call (vi.mock pattern from contacts.test.ts). Test:
- `createAuditNote()` sends POST to correct URL with note body
- Note body contains document type, source, driveFileId, timestamp
- Returns the note ID from response
- Auth error throws CrmAuthError
- Network error throws CrmApiError

**4. Create or update `src/crm/__tests__/contacts.test.ts`:**

If it exists, add tests for `getContact()`. If not, create it. Test:
- `getContact()` sends GET to `/contacts/:contactId` with auth headers
- Returns parsed CrmContact with customFields
- 404 throws CrmApiError
- 401 throws CrmAuthError

Use vi.mock for global fetch, same pattern as existing CRM tests.
  </action>
  <verify>
    Run `npx vitest run` â€” all tests pass including new ones.
    Run `npx tsc --noEmit` â€” zero type errors.
    Verify new test files exist: `src/crm/__tests__/doc-type-matcher.test.ts`, `src/crm/__tests__/notes.test.ts`.
  </verify>
  <done>
    - `findMatchingChecklistDoc()` correctly maps common DocumentType values to their checklist document names
    - Doc-type matcher handles label prefix, contains, and alias strategies
    - At least 12 test cases covering common document types, edge cases, and stage field verification
    - Notes module has tests for happy path and error cases
    - getContact has tests for happy path and error cases
    - All tests pass (existing + new)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` â€” zero errors
2. `npx vitest run` â€” all tests pass (existing + new)
3. Files exist: `src/crm/notes.ts`, `src/crm/doc-type-matcher.ts`
4. `getContact()` exported from `src/crm/contacts.ts`
5. `MissingDocEntry` type exported from `src/crm/types/index.ts`
6. `mapChecklistToDocEntries()` exported from `src/crm/checklist-mapper.ts`
7. `missingDocs` CRM field now stores `MissingDocEntry[]` JSON (verified via checklist-mapper test update)
</verification>

<success_criteria>
- getContact() reads a contact's full record with custom fields from GHL API
- createAuditNote() creates a note on a contact with document receipt details
- findMatchingChecklistDoc() maps classifier DocumentType to checklist document names with >90% accuracy for common doc types
- missingDocs format includes stage information for PRE/FULL counter tracking
- All tests pass (existing + 20+ new tests)
</success_criteria>

<output>
After completion, create `.planning/phases/08-tracking-integration/08-01-SUMMARY.md`
</output>

---
phase: 06-document-intake
plan: 04
type: execute
wave: 3
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - src/intake/gmail-monitor.ts
  - src/intake/finmo-docs.ts
  - src/intake/intake-worker.ts
  - src/intake/index.ts
  - src/intake/__tests__/intake-worker.test.ts
  - src/intake/__tests__/finmo-docs.test.ts
  - src/intake/__tests__/gmail-monitor.test.ts
autonomous: true
user_setup:
  - service: gmail
    why: "Gmail readonly scope needed for docs@ inbox monitoring"
    env_vars:
      - name: DOC_INBOX
        source: "The email address to monitor (e.g., docs@venturemortgages.co)"
    dashboard_config:
      - task: "Add gmail.readonly scope to service account delegation"
        location: "Google Workspace Admin Console -> Security -> API Controls -> Domain-wide Delegation -> Edit scopes for service account"
      - task: "Re-run OAuth consent flow with expanded scopes (if using OAuth2 dev mode)"
        location: "Run: npx tsx src/email/setup/get-refresh-token.ts (includes both compose and readonly scopes)"

must_haves:
  truths:
    - "Gmail inbox is polled on a configurable schedule via BullMQ job scheduler"
    - "Poll results are enqueued as individual intake jobs for processing"
    - "Intake worker downloads attachments, converts to PDF, and produces IntakeDocument objects"
    - "Finmo document webhook events are received and enqueued for processing"
    - "History ID is persisted in Redis across polls for crash recovery"
    - "All intake module exports are available from a single barrel import"
  artifacts:
    - path: "src/intake/gmail-monitor.ts"
      provides: "BullMQ job scheduler for periodic Gmail polling"
      exports: ["startGmailMonitor", "INTAKE_QUEUE_NAME"]
    - path: "src/intake/finmo-docs.ts"
      provides: "Express route handler for Finmo document resthook events"
      exports: ["finmoDocumentHandler"]
    - path: "src/intake/intake-worker.ts"
      provides: "BullMQ worker that processes intake jobs (download + convert + produce IntakeDocument)"
      exports: ["createIntakeWorker", "processIntakeJob", "closeIntakeWorker"]
    - path: "src/intake/index.ts"
      provides: "Barrel export for the intake module"
      exports: ["startGmailMonitor", "createIntakeWorker", "closeIntakeWorker", "finmoDocumentHandler", "INTAKE_QUEUE_NAME"]
    - path: "src/intake/__tests__/intake-worker.test.ts"
      provides: "Tests for intake worker processing pipeline"
      min_lines: 60
    - path: "src/intake/__tests__/finmo-docs.test.ts"
      provides: "Tests for Finmo document webhook handler"
      min_lines: 30
    - path: "src/intake/__tests__/gmail-monitor.test.ts"
      provides: "Tests for Gmail monitor scheduler and historyId Redis persistence"
      min_lines: 30
  key_links:
    - from: "src/intake/gmail-monitor.ts"
      to: "bullmq"
      via: "upsertJobScheduler"
      pattern: "upsertJobScheduler"
    - from: "src/intake/gmail-monitor.ts"
      to: "src/intake/gmail-reader.ts"
      via: "pollForNewMessages in scheduler job"
      pattern: "pollForNewMessages"
    - from: "src/intake/intake-worker.ts"
      to: "src/intake/pdf-converter.ts"
      via: "convertToPdf for non-PDF attachments"
      pattern: "convertToPdf"
    - from: "src/intake/intake-worker.ts"
      to: "src/intake/attachment-extractor.ts"
      via: "extractAttachments + downloadAttachment"
      pattern: "extractAttachments|downloadAttachment"
    - from: "src/intake/gmail-monitor.ts"
      to: "redis"
      via: "GET/SET for historyId crash recovery"
      pattern: "HISTORY_ID_KEY|getStoredHistoryId|storeHistoryId"
    - from: "src/intake/finmo-docs.ts"
      to: "bullmq"
      via: "Queue.add for intake job"
      pattern: "queue\\.add"
---

<objective>
Build the Gmail monitor scheduler, Finmo document webhook handler, intake processing worker, and barrel export. This plan ties together all Phase 6 components into a working document intake system.

Purpose: This is the integration layer. The Gmail monitor schedules periodic polling (INTAKE-01). The Finmo handler receives document upload events (INTAKE-02). The intake worker processes jobs by downloading attachments (INTAKE-03), converting to PDF (INTAKE-04), and producing IntakeDocument objects for Phase 7.

Output: src/intake/gmail-monitor.ts, src/intake/finmo-docs.ts, src/intake/intake-worker.ts, src/intake/index.ts, test suites
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-document-intake/06-RESEARCH.md
@.planning/phases/06-document-intake/06-01-SUMMARY.md
@.planning/phases/06-document-intake/06-02-SUMMARY.md
@.planning/phases/06-document-intake/06-03-SUMMARY.md
@src/webhook/queue.ts
@src/webhook/worker.ts
@src/webhook/server.ts
@src/config.ts
@src/intake/types.ts
@src/intake/config.ts
@src/intake/gmail-reader.ts
@src/intake/attachment-extractor.ts
@src/intake/pdf-converter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Gmail monitor scheduler and Finmo document handler</name>
  <files>src/intake/gmail-monitor.ts, src/intake/finmo-docs.ts, src/intake/__tests__/finmo-docs.test.ts, src/intake/__tests__/gmail-monitor.test.ts</files>
  <action>
**Create `src/intake/gmail-monitor.ts`:**

This module manages the BullMQ job scheduler for periodic Gmail polling. It uses `upsertJobScheduler` (not the deprecated `add` with `repeat`).

```typescript
export const INTAKE_QUEUE_NAME = 'doc-intake';
const HISTORY_ID_KEY = 'intake:gmail:historyId';
```

**`startGmailMonitor(queue: Queue): Promise<void>`**
- Calls `queue.upsertJobScheduler('gmail-poll-docs', { every: intakeConfig.pollIntervalMs }, { name: 'poll-docs-inbox', data: { source: 'gmail', receivedAt: new Date().toISOString() } })`
- Logs: `[intake] Gmail monitor started, polling every ${intakeConfig.pollIntervalMs / 1000}s`
- If `!intakeConfig.enabled`, log warning and return without scheduling: `[intake] Gmail monitor disabled (INTAKE_ENABLED=false)`

**historyId persistence via Redis:**
- **`getStoredHistoryId(): Promise<string | null>`** — Reads `HISTORY_ID_KEY` from Redis using `createRedisConnection()`. Returns null if no key exists (first run). Close the Redis connection after read.
- **`storeHistoryId(historyId: string): Promise<void>`** — Writes `HISTORY_ID_KEY` to Redis using `createRedisConnection()`. Close the Redis connection after write.
- On startup / first poll: call `getStoredHistoryId()`. If null, call `getInitialHistoryId(gmailClient)` and store it. If found, use the stored value as startHistoryId for `pollForNewMessages`.
- After each successful poll: call `storeHistoryId(newHistoryId)` with the historyId returned by `pollForNewMessages`.
- This ensures crash recovery: if the process restarts, it resumes polling from the last successfully processed historyId rather than re-scanning the entire inbox.

**`getIntakeQueue(): Queue`** (lazy singleton, same pattern as `getWebhookQueue`)
- Creates a Queue with name `INTAKE_QUEUE_NAME` and `createRedisConnection()` from `src/webhook/queue.ts`
- Default job options: 3 attempts, exponential backoff (10s base), 24h retention, keep failed jobs

**`closeIntakeQueue(): Promise<void>`** — close and reset singleton

**Create `src/intake/finmo-docs.ts`:**

Express route handler for Finmo "Document request status changed" resthook events.

**`finmoDocumentHandler(queue: Queue): express.RequestHandler`**
- Returns an async Express handler for `POST /webhooks/finmo/documents`
- Extracts `applicationId` and `documentRequestId` from the request body (support multiple payload shapes, same pattern as `extractApplicationId` in server.ts)
- Specifically look for fields: `applicationId`, `data.applicationId`, `documentRequestId`, `data.documentRequestId`
- If status indicates a new upload (check for 'submitted', 'in_review', 'uploaded', or any non-empty status -- since payload format is undocumented, be permissive)
- Enqueue to the intake queue: `queue.add('finmo-doc-upload', { source: 'finmo', applicationId, documentRequestId, receivedAt }, { jobId: 'finmo-doc-' + documentRequestId })`
- Return 202 `{ accepted: true }`
- If no documentRequestId found, return 400 `{ error: 'Missing documentRequestId' }`
- Log accepted events (metadata only, no PII): `[intake] Finmo doc event enqueued: { applicationId, documentRequestId }`

**Create `src/intake/__tests__/finmo-docs.test.ts`:**
- Test handler accepts valid payload with applicationId + documentRequestId -> 202
- Test handler rejects payload without documentRequestId -> 400
- Test handler extracts from nested `data.documentRequestId` shape
- Test dedup via jobId (verify queue.add called with correct jobId)
- Use vi.fn() mock for queue.add. Use supertest with a minimal Express app wrapping the handler.

Use `.js` extensions for all local imports. Follow the patterns from `src/webhook/server.ts` and `src/webhook/queue.ts`.

**Create `src/intake/__tests__/gmail-monitor.test.ts`:**
- Test `getStoredHistoryId` returns null when Redis key does not exist (first run)
- Test `getStoredHistoryId` returns stored value when Redis key exists (crash recovery)
- Test `storeHistoryId` writes the historyId to Redis under `HISTORY_ID_KEY`
- Test `startGmailMonitor` calls `upsertJobScheduler` with correct scheduler config
- Test `startGmailMonitor` skips scheduling when `intakeConfig.enabled` is false
- Mock Redis using vi.mock for `createRedisConnection` — return mock with `get`, `set`, `quit` as vi.fn()
  </action>
  <verify>Run `npx vitest run src/intake/__tests__/finmo-docs.test.ts src/intake/__tests__/gmail-monitor.test.ts` and confirm all tests pass. Run `npx tsc --noEmit` with no errors.</verify>
  <done>Gmail monitor scheduler created with upsertJobScheduler at configurable interval. historyId is persisted in Redis via getStoredHistoryId/storeHistoryId for crash recovery. Finmo document handler accepts resthook events and enqueues to intake queue with dedup. Queue follows same lazy singleton pattern as webhook queue. Tests verify handler responses, payload extraction, dedup jobId, and historyId Redis persistence.</done>
</task>

<task type="auto">
  <name>Task 2: Create intake worker processing pipeline</name>
  <files>src/intake/intake-worker.ts, src/intake/__tests__/intake-worker.test.ts</files>
  <action>
Create `src/intake/intake-worker.ts` — the BullMQ worker that processes intake jobs. This is the core processing pipeline that ties together Gmail reading, attachment extraction, and PDF conversion.

**`processIntakeJob(job: Job<IntakeJobData>): Promise<IntakeResult>`**
- Exported for testing (same pattern as `processJob` in `src/webhook/worker.ts`)
- Two code paths based on `job.data.source`:

**Gmail source (`job.data.source === 'gmail'`):**
1. Get gmail readonly client: `getGmailReadonlyClient(intakeConfig.docsInbox)`
2. Get message details: `getMessageDetails(gmailClient, job.data.gmailMessageId!)`
3. Get full message for attachment extraction: `gmail.users.messages.get({ userId: 'me', id: messageId, format: 'full' })`
4. Extract attachments: `extractAttachments(message.data.payload?.parts ?? [])`
5. Filter attachments: skip attachments where `getConversionStrategy(att.mimeType) === 'unsupported'` and where `att.size > intakeConfig.maxAttachmentBytes`
6. For each valid attachment:
   a. Download: `downloadAttachment(gmailClient, messageId, att.attachmentId)`
   b. Convert to PDF: `convertToPdf(buffer, att.mimeType)` — catch ConversionError and add to errors array (don't fail the whole job)
   c. Create IntakeDocument object with id `gmail-${messageId}-${index}`, source 'gmail', senderEmail from message details, etc.
7. Return IntakeResult with count and ids
8. Log: `[intake] Processed gmail message ${messageId}: ${documentsProcessed} docs, ${errors.length} errors`

**Finmo source (`job.data.source === 'finmo'`):**
1. Log: `[intake] Finmo document intake not yet implemented (INTAKE-02). Enqueued for future processing.`
2. Return `{ documentsProcessed: 0, documentIds: [], errors: ['Finmo document download not implemented'] }`
3. NOTE: Finmo document download requires API calls to `/api/v1/document-requests/files` which is undocumented. Phase 6 detects the webhook event and enqueues it. Actual file download will be implemented when Finmo payload format is confirmed via live testing.

**`createIntakeWorker(): Worker<IntakeJobData, IntakeResult>`** (lazy singleton)
- Same pattern as `createWorker()` in `src/webhook/worker.ts`
- Listens on `INTAKE_QUEUE_NAME`
- Concurrency 1
- On 'completed' and 'failed' event handlers for logging

**`closeIntakeWorker(): Promise<void>`** — close and reset singleton

**Where do IntakeDocuments go?** For Phase 6, the processIntakeJob function produces IntakeDocument objects but does NOT yet send them anywhere. Phase 7 (Classification & Filing) will consume them. For now, log the document metadata (id, source, originalFilename, originalMimeType, senderEmail) and return the result. The IntakeDocument objects are not stored -- they will be enqueued to a Phase 7 queue when that phase is built. Add a TODO comment: `// TODO Phase 7: enqueue IntakeDocument to classification queue`.

**Important:** Do NOT store pdfBuffer in BullMQ job data (anti-pattern from research: buffers can be 10+ MB). The intake worker downloads and processes attachments within the job handler, producing IntakeDocument objects that are immediately consumed or logged. Future Phase 7 integration will either pass file references or write to temp storage.

Create `src/intake/__tests__/intake-worker.test.ts`:
- Mock all dependencies: getGmailReadonlyClient, getMessageDetails, extractAttachments, downloadAttachment, convertToPdf
- Test Gmail source: message with 2 PDF attachments -> 2 IntakeDocuments, no conversion needed
- Test Gmail source: message with 1 JPEG attachment -> 1 IntakeDocument, converted to PDF
- Test Gmail source: message with 1 Word doc -> 0 IntakeDocuments, 1 error (WORD_MANUAL_REVIEW)
- Test Gmail source: attachment exceeds maxAttachmentBytes -> skipped, not in results
- Test Gmail source: message with no attachments -> 0 documents
- Test Finmo source: returns stub result with not-implemented error
- Test IntakeDocument has correct fields (id format, source, senderEmail from message, etc.)

Use vi.mock for module mocks, vi.hoisted for shared mock variables, vi.fn for individual functions. Follow the worker.test.ts patterns from Phase 1.
  </action>
  <verify>Run `npx vitest run src/intake/__tests__/intake-worker.test.ts` and confirm all tests pass. Run `npx tsc --noEmit` with no errors.</verify>
  <done>processIntakeJob handles Gmail source (download -> extract -> convert -> produce IntakeDocument) and Finmo source (stub with TODO). Worker follows singleton pattern with event logging. ConversionError per-attachment is caught and added to errors (no job failure). Oversized attachments are skipped. Tests cover PDF passthrough, image conversion, Word rejection, size filtering, no attachments, and Finmo stub.</done>
</task>

<task type="auto">
  <name>Task 3: Create barrel export and verify full test suite</name>
  <files>src/intake/index.ts</files>
  <action>
Create `src/intake/index.ts` barrel export following the same pattern as `src/email/index.ts` and `src/crm/index.ts`:

```typescript
// Types (type-only exports)
export type {
  IntakeDocument,
  IntakeJobData,
  IntakeResult,
  IntakeSource,
  GmailMessageMeta,
  AttachmentInfo,
  ConversionStrategy,
} from './types.js';

// Config
export { intakeConfig, SUPPORTED_MIME_TYPES, getConversionStrategy } from './config.js';
export type { IntakeConfig } from './config.js';

// Gmail reading
export { pollForNewMessages, getMessageDetails, getInitialHistoryId } from './gmail-reader.js';

// Attachment extraction
export { extractAttachments, downloadAttachment } from './attachment-extractor.js';

// PDF conversion
export { convertToPdf, ConversionError } from './pdf-converter.js';
export type { ConversionResult } from './pdf-converter.js';

// Gmail monitor
export { startGmailMonitor, getIntakeQueue, closeIntakeQueue, INTAKE_QUEUE_NAME } from './gmail-monitor.js';

// Finmo document handler
export { finmoDocumentHandler } from './finmo-docs.js';

// Intake worker
export { createIntakeWorker, processIntakeJob, closeIntakeWorker } from './intake-worker.js';
```

After creating the barrel, run the full test suite to confirm everything works together: `npx vitest run`. All tests (existing 183 + new intake tests) should pass.

Verify export surface by checking that TypeScript can import all listed names from `src/intake/index.js`.
  </action>
  <verify>Run `npx vitest run` and confirm ALL tests pass (existing + new). Run `npx tsc --noEmit` with no errors. Verify src/intake/index.ts exists and exports all listed symbols.</verify>
  <done>Barrel export provides single-import surface for all intake module functionality. Full test suite passes with no regressions. All types, config, reading, extraction, conversion, monitoring, and worker functions are accessible from 'src/intake/index.js'.</done>
</task>

</tasks>

<verification>
- `npx vitest run` passes ALL tests (183 existing + all new intake tests)
- `npx tsc --noEmit` passes with no errors
- Gmail monitor creates BullMQ job scheduler at configurable interval
- Finmo document handler accepts webhook events and enqueues intake jobs
- Intake worker processes Gmail messages: extract attachments, convert to PDF, produce IntakeDocument
- Barrel export provides clean import surface for Phase 7
- No PII in logs (only document metadata: id, filename, mimeType, source)
</verification>

<success_criteria>
- Documents arriving at docs@ inbox are detected via Gmail polling and processed through the intake pipeline
- Finmo document events are received and enqueued (actual download deferred until payload format confirmed)
- PDF, JPEG, PNG attachments produce IntakeDocument objects with PDF buffers
- Word documents are flagged for manual review
- All tests pass including existing regression suite
</success_criteria>

<output>
After completion, create `.planning/phases/06-document-intake/06-04-SUMMARY.md`
</output>

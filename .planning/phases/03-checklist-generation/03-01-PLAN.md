---
phase: 03-checklist-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - vitest.config.ts
  - src/checklist/types/finmo.ts
  - src/checklist/types/checklist.ts
  - src/checklist/types/index.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript project compiles with strict mode enabled"
    - "Finmo application response can be typed without 'any' usage"
    - "Checklist rule interface captures condition, exclusion, scope, stage, and internalOnly"
    - "Generated checklist output separates per-borrower, per-property, shared, and internal items"
  artifacts:
    - path: "package.json"
      provides: "Project configuration with TypeScript and Vitest"
      contains: "vitest"
    - path: "tsconfig.json"
      provides: "TypeScript strict mode configuration"
      contains: "strict"
    - path: "src/checklist/types/finmo.ts"
      provides: "Typed Finmo API response interfaces"
      exports: ["FinmoApplicationResponse", "FinmoBorrower", "FinmoIncome", "FinmoAsset", "FinmoProperty", "FinmoLiability"]
    - path: "src/checklist/types/checklist.ts"
      provides: "Rule engine and output interfaces"
      exports: ["ChecklistRule", "ApplicationContext", "GeneratedChecklist", "ChecklistItem", "InternalFlag"]
    - path: "src/checklist/types/index.ts"
      provides: "Barrel export for all types"
  key_links:
    - from: "src/checklist/types/checklist.ts"
      to: "src/checklist/types/finmo.ts"
      via: "ApplicationContext references Finmo types"
      pattern: "import.*from.*finmo"
---

<objective>
Bootstrap the TypeScript project and define all type interfaces for the checklist generation system.

Purpose: Every subsequent plan depends on these types. Finmo types are derived from the real API sample response (`finmo_app_sample.json`). Checklist types define the rule engine contract. Getting these right prevents cascading type errors in Plans 02-04.

Output: Compilable TypeScript project with complete type definitions for Finmo API data, checklist rules, application context, and generated checklist output.
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-checklist-generation/03-RESEARCH.md
@.planning/finmo_app_sample.json
@DOC_CHECKLIST_RULES_V2.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize TypeScript project with Vitest</name>
  <files>package.json, tsconfig.json, vitest.config.ts</files>
  <action>
Initialize a new Node.js project in the repository root:

1. Run `npm init -y` to create package.json
2. Install dev dependencies: `npm install -D typescript vitest @types/node`
3. Create `tsconfig.json` with:
   - `"strict": true`
   - `"target": "ES2022"`
   - `"module": "NodeNext"`
   - `"moduleResolution": "NodeNext"`
   - `"outDir": "./dist"`
   - `"rootDir": "./src"`
   - `"declaration": true`
   - `"esModuleInterop": true`
   - `"skipLibCheck": true`
   - Include: `["src/**/*"]`
4. Create `vitest.config.ts` with:
   - `test.include: ["src/**/*.test.ts"]`
   - `test.globals: true`
5. Add scripts to package.json:
   - `"build": "tsc"`
   - `"test": "vitest run"`
   - `"test:watch": "vitest"`
6. Set `"type": "module"` in package.json

Do NOT install any rule engine libraries. The checklist engine is custom TypeScript per research decision.
  </action>
  <verify>Run `npx tsc --noEmit` — should succeed with no errors (empty project). Run `npx vitest run` — should succeed with 0 tests found.</verify>
  <done>TypeScript project compiles in strict mode. Vitest is configured and runnable. No external rule engine dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Define Finmo API type interfaces from sample data</name>
  <files>src/checklist/types/finmo.ts</files>
  <action>
Create TypeScript interfaces that model the Finmo API response. Derive these DIRECTLY from the real sample at `.planning/finmo_app_sample.json`. Do not invent fields — only type what exists in the sample, plus known values from the research field mapping table.

Create these interfaces in `src/checklist/types/finmo.ts`:

1. **`FinmoApplicationResponse`** — The top-level API response object with keys: `application`, `applicant`, `borrowers`, `incomes`, `properties`, `assets`, `liabilities`, `addresses`, `addressSituations`, `creditReports`, `activities`, `agents`, `fees`, `teamMembers`, `users`, `referralLink`, `idVerificationRequests`. Only fully type the keys needed for checklist generation (application, borrowers, incomes, properties, assets, liabilities). Others can be typed as `unknown[]` or `unknown`.

2. **`FinmoApplication`** — Key fields: `id` (string), `goal` (`"purchase" | "refinance" | string`), `use` (`"owner_occupied" | string`), `process` (`"searching" | "found_property" | string`), `propertyId` (string | null), `downPayment` (number), `closingDate` (string | null), `status` (string), `purchasePrice` (number), `mortgageAmountRequested` (number), `subjectPropertyProvince` (string | null).

3. **`FinmoBorrower`** — Key fields: `id` (string), `firstName` (string), `lastName` (string), `email` (string), `firstTime` (boolean), `marital` (`"common_law" | "married" | "single" | "divorced" | "separated" | "widowed" | string`), `isMainBorrower` (boolean), `relationshipToMainBorrower` (string | null), `incomes` (string[] — IDs), `addressSituations` (string[] — IDs), `sinNumber` (string — NOTE: never log this).

4. **`FinmoIncome`** — Key fields: `id` (string), `borrowerId` (string), `source` (`"employed" | "self_employed" | "retired" | string`), `income` (number), `incomeFrequency` (string), `payType` (`"salaried" | "hourly" | "commission" | string` | null), `business` (string — employer name), `title` (string), `startDate` (string | null), `endDate` (string | null), `jobType` (`"full_time" | "part_time" | "contract" | string` | null), `bonuses` (boolean), `selfPayType` (unknown[] | null), `active` (boolean), `businessType` (string | null), `industrySector` (string | null).

5. **`FinmoProperty`** — Key fields: `id` (string), `addressId` (string | null), `isSelling` (boolean), `saleDownpaymentAmount` (number | null), `worth` (number | null), `annualTaxes` (number | null), `monthlyFees` (number | null), `use` (string), `mortgaged` (boolean | null), `rentalIncome` (number), `type` (`"detached" | "condo" | "semi_detached" | "townhouse" | string` | null), `tenure` (`"freehold" | "leasehold" | string` | null), `numberOfUnits` (number | null), `purchasePrice` (number | null), `mortgages` (array of mortgage objects with `id`, `remainingAmount`, `lender`, `rate`, `payment`, `payoff`).

6. **`FinmoAsset`** — Key fields: `id` (string), `type` (`"cash_savings" | "rrsp" | "tfsa" | "vehicle" | "other" | string`), `value` (number), `downPayment` (number | null), `description` (string), `owners` (string[] — borrower IDs).

7. **`FinmoLiability`** — Key fields: `id` (string), `type` (`"mortgage" | "unsecured_line_credit" | "credit_card" | "other" | string`), `creditLimit` (number | null), `balance` (number), `monthlyPayment` (number), `description` (string), `owners` (string[] — borrower IDs), `payOffType` (string | null).

Use union types with `| string` fallback for enum-like fields to handle unknown values gracefully. Add JSDoc comments on key fields explaining their role in checklist generation.

IMPORTANT: Do NOT include `sinNumber` in any type that would be used for logging. Add a `/** @sensitive Never log this field */` JSDoc on sinNumber.
  </action>
  <verify>Run `npx tsc --noEmit` — should compile with no errors.</verify>
  <done>All Finmo API types are defined with proper union types. Fields match the real sample data. Sensitive fields are annotated.</done>
</task>

<task type="auto">
  <name>Task 3: Define checklist rule engine and output interfaces</name>
  <files>src/checklist/types/checklist.ts, src/checklist/types/index.ts</files>
  <action>
Create the core type interfaces for the rule engine, application context, and generated checklist output in `src/checklist/types/checklist.ts`.

1. **`ChecklistRule`** — The core rule definition:
   ```
   id: string                          // e.g., "s1_employed_paystub"
   section: string                     // e.g., "1_income_employed_salary"
   document: string                    // Internal doc name: "Recent paystub (within 30 days)"
   displayName: string                 // Email-friendly: "2 recent pay stubs (must show YTD earnings)"
   stage: 'PRE' | 'FULL' | 'LATER' | 'CONDITIONAL' | 'LENDER_CONDITION'
   scope: 'per_borrower' | 'per_property' | 'shared'
   condition: (ctx: RuleContext) => boolean
   excludeWhen?: (ctx: RuleContext) => boolean  // CHKL-05: when to NOT include despite condition match
   notes?: string                      // Conditional note for email (e.g., "if NOA shows amount owing...")
   internalOnly?: boolean              // true = tracked internally, NOT sent to client (CHKL-06)
   internalCheckNote?: string          // For internal checks: "Verify T1 includes T2125"
   ```

2. **`RuleContext`** — What each rule receives for evaluation. This is PER-BORROWER when scope is per_borrower:
   ```
   application: FinmoApplication
   borrower: FinmoBorrower              // Current borrower being evaluated (for per_borrower rules)
   borrowerIncomes: FinmoIncome[]       // Current borrower's income entries
   allBorrowers: FinmoBorrower[]
   allIncomes: FinmoIncome[]
   assets: FinmoAsset[]                 // All application assets
   borrowerAssets: FinmoAsset[]         // Assets owned by current borrower
   properties: FinmoProperty[]          // All properties
   subjectProperty: FinmoProperty | null
   liabilities: FinmoLiability[]        // All liabilities
   borrowerLiabilities: FinmoLiability[] // Liabilities owned by current borrower
   currentDate: Date                    // For dynamic tax year calculation
   ```

3. **`GeneratedChecklist`** — The complete output:
   ```
   applicationId: string
   generatedAt: string                  // ISO timestamp
   borrowerChecklists: BorrowerChecklist[]
   propertyChecklists: PropertyChecklist[]
   sharedItems: ChecklistItem[]
   internalFlags: InternalFlag[]
   warnings: string[]                   // Unknown field values, ambiguous data, etc.
   ```

4. **`BorrowerChecklist`**:
   ```
   borrowerId: string
   borrowerName: string                 // "Lyndon Cameron"
   isMainBorrower: boolean
   items: ChecklistItem[]
   ```

5. **`PropertyChecklist`**:
   ```
   propertyId: string
   propertyDescription: string          // "4940 Daryl Road, Kelowna" or "Subject Property"
   items: ChecklistItem[]
   ```

6. **`ChecklistItem`**:
   ```
   ruleId: string
   document: string                     // Internal name
   displayName: string                  // Email-friendly name
   stage: 'PRE' | 'FULL' | 'LATER' | 'CONDITIONAL' | 'LENDER_CONDITION'
   notes?: string                       // Conditional note
   forEmail: boolean                    // false = internalOnly items
   section: string                      // Original section for grouping
   ```

7. **`InternalFlag`**:
   ```
   ruleId: string
   description: string                  // "Gift letter — collect when lender picked"
   type: 'deferred_doc' | 'internal_check' | 'manual_flag'
   borrowerName?: string                // If per-borrower
   checkNote?: string                   // "Verify T1 includes T2125"
   ```

8. **`ChecklistStats`** — Summary for downstream consumers:
   ```
   totalItems: number
   preItems: number
   fullItems: number
   perBorrowerItems: number
   sharedItems: number
   internalFlags: number
   warnings: number
   ```

Create `src/checklist/types/index.ts` as a barrel file that re-exports everything from both `finmo.ts` and `checklist.ts`.

Ensure all imports between the two files use relative paths with `.js` extension (required for NodeNext module resolution).
  </action>
  <verify>Run `npx tsc --noEmit` — should compile with no errors. Verify the barrel export works by checking all types are accessible from `src/checklist/types/index.ts`.</verify>
  <done>All type interfaces are defined. ChecklistRule has condition + excludeWhen functions. GeneratedChecklist separates per-borrower, per-property, shared, and internal items. Barrel export re-exports all types.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` succeeds with zero errors
2. `npx vitest run` runs successfully (0 tests, but no configuration errors)
3. All type files exist and export named interfaces
4. No `any` types used in Finmo interfaces (union types with string fallback instead)
5. No rule engine libraries in package.json dependencies
</verification>

<success_criteria>
- TypeScript project compiles in strict mode
- Finmo types match the real API sample structure
- ChecklistRule interface supports conditions, exclusions, scope, stage, and internal-only flags
- GeneratedChecklist output is structured for both email (Phase 5) and CRM (Phase 4) consumers
- All types are accessible via barrel export
</success_criteria>

<output>
After completion, create `.planning/phases/03-checklist-generation/03-01-SUMMARY.md`
</output>

---
phase: 11-drive-folder-linking-deal-subfolders
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/classification/classification-worker.ts
  - src/crm/tracking-sync.ts
  - src/classification/__tests__/classification-worker.test.ts
autonomous: true
requirements: [DRIVE-02, DRIVE-04, DRIVE-05, DRIVE-07]

must_haves:
  truths:
    - "Classification worker reads clientFolderId from CRM contact custom field instead of using global root"
    - "Reusable docs (non-property-specific) are filed to client folder subfolders"
    - "Property-specific docs are filed to deal subfolder when available"
    - "Falls back to DRIVE_ROOT_FOLDER_ID when CRM contact has no folder ID"
    - "Contact is fetched once and shared between folder resolution and tracking sync"
  artifacts:
    - path: "src/classification/classification-worker.ts"
      provides: "CRM-based folder resolution with fallback chain"
      contains: "getContactDriveFolderId"
    - path: "src/crm/tracking-sync.ts"
      provides: "updateDocTracking accepts optional pre-fetched contact"
      contains: "prefetchedContact"
    - path: "src/classification/__tests__/classification-worker.test.ts"
      provides: "Tests for folder resolution fallback chain"
      contains: "driveFolderIdFieldId"
  key_links:
    - from: "src/classification/classification-worker.ts"
      to: "src/crm/contacts.ts"
      via: "getContact + getContactDriveFolderId for folder resolution"
      pattern: "getContactDriveFolderId.*driveFolderIdFieldId"
    - from: "src/classification/classification-worker.ts"
      to: "src/crm/opportunities.ts"
      via: "findOpportunityByFinmoId + getOpportunityFieldValue for deal subfolder"
      pattern: "oppDealSubfolderIdFieldId"
    - from: "src/classification/classification-worker.ts"
      to: "src/drive/doc-expiry.ts"
      via: "PROPERTY_SPECIFIC_TYPES to decide deal vs client routing"
      pattern: "PROPERTY_SPECIFIC_TYPES\\.has"
---

<objective>
Refactor the classification worker to read folder IDs from CRM and route docs to the correct location.

Purpose: The classification worker currently uses DRIVE_ROOT_FOLDER_ID as a catch-all for filing, which means docs land in the wrong folder. This plan teaches it to read the client folder ID from the CRM contact, resolve the deal subfolder from the opportunity for property-specific docs, and fall back gracefully when fields are missing.

Output: Classification worker files to correct folders via CRM-stored folder IDs with full fallback chain.
</objective>

<execution_context>
@C:/Users/lucac/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/lucac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-drive-folder-linking-deal-subfolders/11-RESEARCH.md
@.planning/phases/11-drive-folder-linking-deal-subfolders/11-01-SUMMARY.md

@src/classification/classification-worker.ts
@src/crm/tracking-sync.ts
@src/crm/contacts.ts
@src/crm/config.ts
@src/crm/opportunities.ts
@src/drive/doc-expiry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor classification worker for CRM-based folder resolution</name>
  <files>
    src/classification/classification-worker.ts
    src/crm/tracking-sync.ts
  </files>
  <action>
1. In `src/classification/classification-worker.ts`:

   a. Add imports:
      - `getContact` from `../crm/contacts.js` (if not already imported)
      - `getContactDriveFolderId` from `../crm/contacts.js` (new helper from 11-01)
      - `crmConfig` from `../crm/config.js`
      - `findOpportunityByFinmoId`, `getOpportunityFieldValue` from `../crm/opportunities.js`
      - `PROPERTY_SPECIFIC_TYPES` from `../drive/doc-expiry.js`
      - `PIPELINE_IDS` from `../crm/types/index.js`
      - `CrmContact` type from `../crm/types/index.js`

   b. Replace the current folder resolution block (lines ~129-170, from `// e. Resolve client Drive folder` to the manual review fallback) with a CRM-based resolution chain:

      ```typescript
      // e. Resolve client Drive folder from CRM contact (DRIVE-02)
      let clientFolderId: string | null = null;
      let dealSubfolderId: string | null = null;
      let contact: CrmContact | null = null;

      if (contactId) {
        try {
          // Fetch contact ONCE — shared with tracking-sync later (DRIVE-02, rate limit optimization)
          contact = await getContact(contactId);
          clientFolderId = getContactDriveFolderId(contact, crmConfig.driveFolderIdFieldId);

          if (clientFolderId) {
            console.log('[classification] Resolved client folder from CRM contact:', {
              hasClientFolder: true,
            });
          }
        } catch (err) {
          console.error('[classification] Failed to read contact folder ID (non-fatal):', {
            error: err instanceof Error ? err.message : String(err),
          });
        }
      }

      // Fallback to global root folder (DRIVE-07)
      if (!clientFolderId && classificationConfig.driveRootFolderId) {
        clientFolderId = classificationConfig.driveRootFolderId;
        console.log('[classification] Using DRIVE_ROOT_FOLDER_ID fallback');
      }

      // If still no folder, route to manual review
      if (!clientFolderId) {
        console.warn('[classification] Cannot resolve client Drive folder, routing to manual review');
        try {
          if (contactId) {
            await createReviewTask(
              contactId,
              `Manual Review: ${originalFilename}`,
              `Could not resolve client Drive folder. Document type: ${classification.documentType}. ` +
                `Source: ${source}. Please file manually.`,
            );
          }
        } catch {
          // CRM task creation failure is non-fatal
        }
        await unlink(tempFilePath).catch(() => {});
        return {
          intakeDocumentId,
          classification,
          filed: false,
          driveFileId: null,
          manualReview: true,
          error: null,
        };
      }

      // For property-specific docs, resolve deal subfolder from opportunity (DRIVE-05)
      const isPropertySpecific = PROPERTY_SPECIFIC_TYPES.has(classification.documentType);

      if (isPropertySpecific && contactId && applicationId) {
        try {
          const opp = await findOpportunityByFinmoId(
            contactId,
            PIPELINE_IDS.LIVE_DEALS,
            applicationId,
          );
          if (opp) {
            const subfolderId = getOpportunityFieldValue(
              opp,
              crmConfig.oppDealSubfolderIdFieldId,
            );
            if (typeof subfolderId === 'string' && subfolderId.length > 0) {
              dealSubfolderId = subfolderId;
              console.log('[classification] Resolved deal subfolder from opportunity');
            }
          }
        } catch (err) {
          // Non-fatal: fall back to client folder for property-specific docs
          console.error('[classification] Failed to resolve deal subfolder (non-fatal):', {
            error: err instanceof Error ? err.message : String(err),
          });
        }
      }
      ```

   c. Update the folder routing logic (step g, "Resolve target folder in Drive"). Replace the simple `resolveTargetFolder` call with routing based on property-specific vs reusable:

      ```typescript
      // g. Resolve target folder in Drive (DRIVE-04/DRIVE-05)
      const drive = getDriveClient();
      const baseFolderId = (isPropertySpecific && dealSubfolderId)
        ? dealSubfolderId   // Property-specific docs -> deal subfolder
        : clientFolderId;   // Reusable docs -> client folder

      const targetFolderId = await resolveTargetFolder(
        drive,
        baseFolderId,
        subfolderTarget,
        personName,
      );
      ```

   d. Update the tracking sync call (step j) to pass the pre-fetched contact. Add `contact` to the updateDocTracking call so it doesn't need to call getContact again:

      ```typescript
      const trackingResult = await updateDocTracking({
        senderEmail: senderEmail ?? '',
        documentType: classification.documentType,
        driveFileId,
        source,
        receivedAt: job.data.receivedAt,
        ...(contactId ? { contactId } : {}),
        finmoApplicationId: applicationId ?? undefined,
        prefetchedContact: contact ?? undefined,
      });
      ```

2. In `src/crm/tracking-sync.ts`:

   a. Add `prefetchedContact?: CrmContact` to the `TrackingUpdateInput` interface. This is an optional parameter — when provided, `updateDocTracking` skips the `getContact()` call and uses the pre-fetched record instead.

   b. In the `updateDocTracking` function, modify step 2 (get contact record):
      ```typescript
      // 2. Get contact record (use pre-fetched if available to save API call)
      const contact = input.prefetchedContact ?? await getContact(contactId);
      ```
      Import `CrmContact` type if not already imported (it is imported).

   c. This change is backward-compatible: callers that don't pass `prefetchedContact` still work exactly as before (getContact is called). The classification worker saves one API call per job.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no type errors.
    Run `npx vitest run` to confirm all existing tests still pass.
  </verify>
  <done>
    Classification worker reads clientFolderId from CRM contact via getContactDriveFolderId.
    Property-specific docs route to deal subfolder when available, reusable docs route to client folder.
    Fallback chain: CRM contact field -> DRIVE_ROOT_FOLDER_ID -> manual review.
    Contact fetched once and shared between folder resolution and tracking-sync.
    updateDocTracking accepts optional prefetchedContact parameter.
    All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for classification worker folder resolution</name>
  <files>
    src/classification/__tests__/classification-worker.test.ts
  </files>
  <action>
1. In the existing classification worker test file, add a new `describe` block for folder resolution:

   ```
   describe('folder resolution', () => { ... })
   ```

2. Test cases (mock getContact, getContactDriveFolderId, findOpportunityByFinmoId, getOpportunityFieldValue using vi.mock):

   a. **CRM contact has Drive folder ID**: Mock getContact returning a contact with the driveFolderIdFieldId custom field set. Verify the classification job uses that folder ID (not DRIVE_ROOT_FOLDER_ID) as the base for resolveTargetFolder. Assert resolveTargetFolder is called with the CRM-provided folder ID.

   b. **CRM contact has no Drive folder ID — fallback to root**: Mock getContact returning a contact without the field. Verify classificationConfig.driveRootFolderId is used as fallback (DRIVE-07). Assert resolveTargetFolder is called with the root folder ID.

   c. **Property-specific doc routes to deal subfolder**: Mock a property-specific doc type (e.g., `purchase_agreement`). Mock findOpportunityByFinmoId returning an opportunity with the deal subfolder ID. Verify resolveTargetFolder is called with the deal subfolder ID as the base folder.

   d. **Property-specific doc without deal subfolder — falls back to client folder**: Mock findOpportunityByFinmoId returning an opportunity without the subfolder field set. Verify resolveTargetFolder falls back to the client folder ID.

   e. **Reusable doc always routes to client folder**: Mock a reusable doc type (e.g., `pay_stub`). Verify resolveTargetFolder is called with the client folder ID even when a deal subfolder exists.

   f. **getContact failure — non-fatal fallback**: Mock getContact throwing an error. Verify the job still completes using DRIVE_ROOT_FOLDER_ID fallback.

3. Follow the existing test patterns in the file:
   - Use vi.hoisted() for mock variables (Vitest 4 pattern)
   - Use vi.mock() with factory functions for module mocking
   - Use the MockQueue class-based constructor pattern if needed
   - Create minimal Job objects matching ClassificationJobData

4. Each test should verify the correct folder ID flows through to resolveTargetFolder, not test resolveTargetFolder itself (that's already tested in filer.test.ts).
  </action>
  <verify>
    Run `npx vitest run src/classification/__tests__/classification-worker.test.ts` to confirm new tests pass.
    Run `npx vitest run` to confirm all tests pass.
  </verify>
  <done>
    6+ test cases covering: CRM folder ID resolution, root folder fallback, property-specific routing to deal subfolder, deal subfolder fallback to client folder, reusable doc routing, and getContact failure handling.
    All tests pass.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npx vitest run` passes with all existing + new tests
- Classification worker imports and uses getContactDriveFolderId
- Property-specific doc types route to deal subfolder
- Reusable doc types route to client folder
- DRIVE_ROOT_FOLDER_ID fallback works when CRM field is empty
- getContact called once per job (shared with tracking-sync via prefetchedContact)
</verification>

<success_criteria>
- Classification worker reads Drive folder ID from CRM contact instead of always using root
- Property-specific docs (purchase_agreement, MLS, etc.) routed to deal subfolder
- Reusable docs (pay_stub, T4, etc.) routed to client folder
- Graceful fallback chain: CRM field -> root folder -> manual review
- Pre-fetched contact shared across folder resolution and tracking-sync
- 6+ new test cases validating folder resolution logic
</success_criteria>

<output>
After completion, create `.planning/phases/11-drive-folder-linking-deal-subfolders/11-03-SUMMARY.md`
</output>
